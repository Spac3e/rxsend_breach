--[[
Server Name: Begotten III: Jesus Wept
Server IP:   208.103.169.119:27015
File Path:   gamemodes/clockwork/gamemode/external/utf8.lua
       
--]]

-- $Id: utf8.lua 179 2009-04-03 18:10:03Z pasta $
--
-- Provides UTF-8 aware string functions extended from Garry's Mod's utf8 module:
-- * utf8.clen
-- * utf8.sub(s, i, j)
-- * utf8.upper(s)
-- * utf8.lower(s)
-- * utf8.reverse(s)
-- * utf8.uchar(unicode)
-- * utf8.unicode(s, i, j)
-- * utf8.gensub(s, sub_len)
--
-- All functions behave as their non UTF-8 aware counterparts with the exception
-- that UTF-8 characters are used instead of bytes for all units.

--[[
Copyright (c) 2006-2007, Kyle Smith
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

	* Redistributions of source code must retain the above copyright notice,
		this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright
		notice, this list of conditions and the following disclaimer in the
		documentation and/or other materials provided with the distribution.
	* Neither the name of the author nor the names of its contributors may be
		used to endorse or promote products derived from this software without
		specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--]]

-- ABNF from RFC 3629
--
-- UTF8-octets = *(UTF8-char)
-- UTF8-char	 = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4
-- UTF8-1		= %x00-7F
-- UTF8-2		= %xC2-DF UTF8-tail
-- UTF8-3		= %xE0 %xA0-BF UTF8-tail / %xE1-EC 2(UTF8-tail) /
--				 %xED %x80-9F UTF8-tail / %xEE-EF 2(UTF8-tail)
-- UTF8-4		= %xF0 %x90-BF 2(UTF8-tail) / %xF1-F3 3(UTF8-tail) /
--				 %xF4 %x80-8F 2(UTF8-tail)
-- UTF8-tail	 = %x80-BF
--

utf8 = utf8 or {} -- Module sanity check

utf8_lc_uc = {
	["a"] = "A",
	["b"] = "B",
	["c"] = "C",
	["d"] = "D",
	["e"] = "E",
	["f"] = "F",
	["g"] = "G",
	["h"] = "H",
	["i"] = "I",
	["j"] = "J",
	["k"] = "K",
	["l"] = "L",
	["m"] = "M",
	["n"] = "N",
	["o"] = "O",
	["p"] = "P",
	["q"] = "Q",
	["r"] = "R",
	["s"] = "S",
	["t"] = "T",
	["u"] = "U",
	["v"] = "V",
	["w"] = "W",
	["x"] = "X",
	["y"] = "Y",
	["z"] = "Z",
	["µ"] = "Μ",
	["à"] = "À",
	["á"] = "Á",
	["â"] = "Â",
	["ã"] = "Ã",
	["ä"] = "Ä",
	["å"] = "Å",
	["æ"] = "Æ",
	["ç"] = "Ç",
	["è"] = "È",
	["é"] = "É",
	["ê"] = "Ê",
	["ë"] = "Ë",
	["ì"] = "Ì",
	["í"] = "Í",
	["î"] = "Î",
	["ï"] = "Ï",
	["ð"] = "Ð",
	["ñ"] = "Ñ",
	["ò"] = "Ò",
	["ó"] = "Ó",
	["ô"] = "Ô",
	["õ"] = "Õ",
	["ö"] = "Ö",
	["ø"] = "Ø",
	["ù"] = "Ù",
	["ú"] = "Ú",
	["û"] = "Û",
	["ü"] = "Ü",
	["ý"] = "Ý",
	["þ"] = "Þ",
	["ÿ"] = "Ÿ",
	["ā"] = "Ā",
	["ă"] = "Ă",
	["ą"] = "Ą",
	["ć"] = "Ć",
	["ĉ"] = "Ĉ",
	["ċ"] = "Ċ",
	["č"] = "Č",
	["ď"] = "Ď",
	["đ"] = "Đ",
	["ē"] = "Ē",
	["ĕ"] = "Ĕ",
	["ė"] = "Ė",
	["ę"] = "Ę",
	["ě"] = "Ě",
	["ĝ"] = "Ĝ",
	["ğ"] = "Ğ",
	["ġ"] = "Ġ",
	["ģ"] = "Ģ",
	["ĥ"] = "Ĥ",
	["ħ"] = "Ħ",
	["ĩ"] = "Ĩ",
	["ī"] = "Ī",
	["ĭ"] = "Ĭ",
	["į"] = "Į",
	["ı"] = "I",
	["ĳ"] = "Ĳ",
	["ĵ"] = "Ĵ",
	["ķ"] = "Ķ",
	["ĺ"] = "Ĺ",
	["ļ"] = "Ļ",
	["ľ"] = "Ľ",
	["ŀ"] = "Ŀ",
	["ł"] = "Ł",
	["ń"] = "Ń",
	["ņ"] = "Ņ",
	["ň"] = "Ň",
	["ŋ"] = "Ŋ",
	["ō"] = "Ō",
	["ŏ"] = "Ŏ",
	["ő"] = "Ő",
	["œ"] = "Œ",
	["ŕ"] = "Ŕ",
	["ŗ"] = "Ŗ",
	["ř"] = "Ř",
	["ś"] = "Ś",
	["ŝ"] = "Ŝ",
	["ş"] = "Ş",
	["š"] = "Š",
	["ţ"] = "Ţ",
	["ť"] = "Ť",
	["ŧ"] = "Ŧ",
	["ũ"] = "Ũ",
	["ū"] = "Ū",
	["ŭ"] = "Ŭ",
	["ů"] = "Ů",
	["ű"] = "Ű",
	["ų"] = "Ų",
	["ŵ"] = "Ŵ",
	["ŷ"] = "Ŷ",
	["ź"] = "Ź",
	["ż"] = "Ż",
	["ž"] = "Ž",
	["ſ"] = "S",
	["ƀ"] = "Ƀ",
	["ƃ"] = "Ƃ",
	["ƅ"] = "Ƅ",
	["ƈ"] = "Ƈ",
	["ƌ"] = "Ƌ",
	["ƒ"] = "Ƒ",
	["ƕ"] = "Ƕ",
	["ƙ"] = "Ƙ",
	["ƚ"] = "Ƚ",
	["ƞ"] = "Ƞ",
	["ơ"] = "Ơ",
	["ƣ"] = "Ƣ",
	["ƥ"] = "Ƥ",
	["ƨ"] = "Ƨ",
	["ƭ"] = "Ƭ",
	["ư"] = "Ư",
	["ƴ"] = "Ƴ",
	["ƶ"] = "Ƶ",
	["ƹ"] = "Ƹ",
	["ƽ"] = "Ƽ",
	["ƿ"] = "Ƿ",
	["ǅ"] = "Ǆ",
	["ǆ"] = "Ǆ",
	["ǈ"] = "Ǉ",
	["ǉ"] = "Ǉ",
	["ǋ"] = "Ǌ",
	["ǌ"] = "Ǌ",
	["ǎ"] = "Ǎ",
	["ǐ"] = "Ǐ",
	["ǒ"] = "Ǒ",
	["ǔ"] = "Ǔ",
	["ǖ"] = "Ǖ",
	["ǘ"] = "Ǘ",
	["ǚ"] = "Ǚ",
	["ǜ"] = "Ǜ",
	["ǝ"] = "Ǝ",
	["ǟ"] = "Ǟ",
	["ǡ"] = "Ǡ",
	["ǣ"] = "Ǣ",
	["ǥ"] = "Ǥ",
	["ǧ"] = "Ǧ",
	["ǩ"] = "Ǩ",
	["ǫ"] = "Ǫ",
	["ǭ"] = "Ǭ",
	["ǯ"] = "Ǯ",
	["ǲ"] = "Ǳ",
	["ǳ"] = "Ǳ",
	["ǵ"] = "Ǵ",
	["ǹ"] = "Ǹ",
	["ǻ"] = "Ǻ",
	["ǽ"] = "Ǽ",
	["ǿ"] = "Ǿ",
	["ȁ"] = "Ȁ",
	["ȃ"] = "Ȃ",
	["ȅ"] = "Ȅ",
	["ȇ"] = "Ȇ",
	["ȉ"] = "Ȉ",
	["ȋ"] = "Ȋ",
	["ȍ"] = "Ȍ",
	["ȏ"] = "Ȏ",
	["ȑ"] = "Ȑ",
	["ȓ"] = "Ȓ",
	["ȕ"] = "Ȕ",
	["ȗ"] = "Ȗ",
	["ș"] = "Ș",
	["ț"] = "Ț",
	["ȝ"] = "Ȝ",
	["ȟ"] = "Ȟ",
	["ȣ"] = "Ȣ",
	["ȥ"] = "Ȥ",
	["ȧ"] = "Ȧ",
	["ȩ"] = "Ȩ",
	["ȫ"] = "Ȫ",
	["ȭ"] = "Ȭ",
	["ȯ"] = "Ȯ",
	["ȱ"] = "Ȱ",
	["ȳ"] = "Ȳ",
	["ȼ"] = "Ȼ",
	["ɂ"] = "Ɂ",
	["ɇ"] = "Ɇ",
	["ɉ"] = "Ɉ",
	["ɋ"] = "Ɋ",
	["ɍ"] = "Ɍ",
	["ɏ"] = "Ɏ",
	["ɓ"] = "Ɓ",
	["ɔ"] = "Ɔ",
	["ɖ"] = "Ɖ",
	["ɗ"] = "Ɗ",
	["ə"] = "Ə",
	["ɛ"] = "Ɛ",
	["ɠ"] = "Ɠ",
	["ɣ"] = "Ɣ",
	["ɨ"] = "Ɨ",
	["ɩ"] = "Ɩ",
	["ɫ"] = "Ɫ",
	["ɯ"] = "Ɯ",
	["ɲ"] = "Ɲ",
	["ɵ"] = "Ɵ",
	["ɽ"] = "Ɽ",
	["ʀ"] = "Ʀ",
	["ʃ"] = "Ʃ",
	["ʈ"] = "Ʈ",
	["ʉ"] = "Ʉ",
	["ʊ"] = "Ʊ",
	["ʋ"] = "Ʋ",
	["ʌ"] = "Ʌ",
	["ʒ"] = "Ʒ",
	["ͅ"] = "Ι",
	["ͻ"] = "Ͻ",
	["ͼ"] = "Ͼ",
	["ͽ"] = "Ͽ",
	["ά"] = "Ά",
	["έ"] = "Έ",
	["ή"] = "Ή",
	["ί"] = "Ί",
	["α"] = "Α",
	["β"] = "Β",
	["γ"] = "Γ",
	["δ"] = "Δ",
	["ε"] = "Ε",
	["ζ"] = "Ζ",
	["η"] = "Η",
	["θ"] = "Θ",
	["ι"] = "Ι",
	["κ"] = "Κ",
	["λ"] = "Λ",
	["μ"] = "Μ",
	["ν"] = "Ν",
	["ξ"] = "Ξ",
	["ο"] = "Ο",
	["π"] = "Π",
	["ρ"] = "Ρ",
	["ς"] = "Σ",
	["σ"] = "Σ",
	["τ"] = "Τ",
	["υ"] = "Υ",
	["φ"] = "Φ",
	["χ"] = "Χ",
	["ψ"] = "Ψ",
	["ω"] = "Ω",
	["ϊ"] = "Ϊ",
	["ϋ"] = "Ϋ",
	["ό"] = "Ό",
	["ύ"] = "Ύ",
	["ώ"] = "Ώ",
	["ϐ"] = "Β",
	["ϑ"] = "Θ",
	["ϕ"] = "Φ",
	["ϖ"] = "Π",
	["ϙ"] = "Ϙ",
	["ϛ"] = "Ϛ",
	["ϝ"] = "Ϝ",
	["ϟ"] = "Ϟ",
	["ϡ"] = "Ϡ",
	["ϣ"] = "Ϣ",
	["ϥ"] = "Ϥ",
	["ϧ"] = "Ϧ",
	["ϩ"] = "Ϩ",
	["ϫ"] = "Ϫ",
	["ϭ"] = "Ϭ",
	["ϯ"] = "Ϯ",
	["ϰ"] = "Κ",
	["ϱ"] = "Ρ",
	["ϲ"] = "Ϲ",
	["ϵ"] = "Ε",
	["ϸ"] = "Ϸ",
	["ϻ"] = "Ϻ",
	["а"] = "А",
	["б"] = "Б",
	["в"] = "В",
	["г"] = "Г",
	["д"] = "Д",
	["е"] = "Е",
	["ж"] = "Ж",
	["з"] = "З",
	["и"] = "И",
	["й"] = "Й",
	["к"] = "К",
	["л"] = "Л",
	["м"] = "М",
	["н"] = "Н",
	["о"] = "О",
	["п"] = "П",
	["р"] = "Р",
	["с"] = "С",
	["т"] = "Т",
	["у"] = "У",
	["ф"] = "Ф",
	["х"] = "Х",
	["ц"] = "Ц",
	["ч"] = "Ч",
	["ш"] = "Ш",
	["щ"] = "Щ",
	["ъ"] = "Ъ",
	["ы"] = "Ы",
	["ь"] = "Ь",
	["э"] = "Э",
	["ю"] = "Ю",
	["я"] = "Я",
	["ѐ"] = "Ѐ",
	["ё"] = "Ё",
	["ђ"] = "Ђ",
	["ѓ"] = "Ѓ",
	["є"] = "Є",
	["ѕ"] = "Ѕ",
	["і"] = "І",
	["ї"] = "Ї",
	["ј"] = "Ј",
	["љ"] = "Љ",
	["њ"] = "Њ",
	["ћ"] = "Ћ",
	["ќ"] = "Ќ",
	["ѝ"] = "Ѝ",
	["ў"] = "Ў",
	["џ"] = "Џ",
	["ѡ"] = "Ѡ",
	["ѣ"] = "Ѣ",
	["ѥ"] = "Ѥ",
	["ѧ"] = "Ѧ",
	["ѩ"] = "Ѩ",
	["ѫ"] = "Ѫ",
	["ѭ"] = "Ѭ",
	["ѯ"] = "Ѯ",
	["ѱ"] = "Ѱ",
	["ѳ"] = "Ѳ",
	["ѵ"] = "Ѵ",
	["ѷ"] = "Ѷ",
	["ѹ"] = "Ѹ",
	["ѻ"] = "Ѻ",
	["ѽ"] = "Ѽ",
	["ѿ"] = "Ѿ",
	["ҁ"] = "Ҁ",
	["ҋ"] = "Ҋ",
	["ҍ"] = "Ҍ",
	["ҏ"] = "Ҏ",
	["ґ"] = "Ґ",
	["ғ"] = "Ғ",
	["ҕ"] = "Ҕ",
	["җ"] = "Җ",
	["ҙ"] = "Ҙ",
	["қ"] = "Қ",
	["ҝ"] = "Ҝ",
	["ҟ"] = "Ҟ",
	["ҡ"] = "Ҡ",
	["ң"] = "Ң",
	["ҥ"] = "Ҥ",
	["ҧ"] = "Ҧ",
	["ҩ"] = "Ҩ",
	["ҫ"] = "Ҫ",
	["ҭ"] = "Ҭ",
	["ү"] = "Ү",
	["ұ"] = "Ұ",
	["ҳ"] = "Ҳ",
	["ҵ"] = "Ҵ",
	["ҷ"] = "Ҷ",
	["ҹ"] = "Ҹ",
	["һ"] = "Һ",
	["ҽ"] = "Ҽ",
	["ҿ"] = "Ҿ",
	["ӂ"] = "Ӂ",
	["ӄ"] = "Ӄ",
	["ӆ"] = "Ӆ",
	["ӈ"] = "Ӈ",
	["ӊ"] = "Ӊ",
	["ӌ"] = "Ӌ",
	["ӎ"] = "Ӎ",
	["ӏ"] = "Ӏ",
	["ӑ"] = "Ӑ",
	["ӓ"] = "Ӓ",
	["ӕ"] = "Ӕ",
	["ӗ"] = "Ӗ",
	["ә"] = "Ә",
	["ӛ"] = "Ӛ",
	["ӝ"] = "Ӝ",
	["ӟ"] = "Ӟ",
	["ӡ"] = "Ӡ",
	["ӣ"] = "Ӣ",
	["ӥ"] = "Ӥ",
	["ӧ"] = "Ӧ",
	["ө"] = "Ө",
	["ӫ"] = "Ӫ",
	["ӭ"] = "Ӭ",
	["ӯ"] = "Ӯ",
	["ӱ"] = "Ӱ",
	["ӳ"] = "Ӳ",
	["ӵ"] = "Ӵ",
	["ӷ"] = "Ӷ",
	["ӹ"] = "Ӹ",
	["ӻ"] = "Ӻ",
	["ӽ"] = "Ӽ",
	["ӿ"] = "Ӿ",
	["ԁ"] = "Ԁ",
	["ԃ"] = "Ԃ",
	["ԅ"] = "Ԅ",
	["ԇ"] = "Ԇ",
	["ԉ"] = "Ԉ",
	["ԋ"] = "Ԋ",
	["ԍ"] = "Ԍ",
	["ԏ"] = "Ԏ",
	["ԑ"] = "Ԑ",
	["ԓ"] = "Ԓ",
	["ա"] = "Ա",
	["բ"] = "Բ",
	["գ"] = "Գ",
	["դ"] = "Դ",
	["ե"] = "Ե",
	["զ"] = "Զ",
	["է"] = "Է",
	["ը"] = "Ը",
	["թ"] = "Թ",
	["ժ"] = "Ժ",
	["ի"] = "Ի",
	["լ"] = "Լ",
	["խ"] = "Խ",
	["ծ"] = "Ծ",
	["կ"] = "Կ",
	["հ"] = "Հ",
	["ձ"] = "Ձ",
	["ղ"] = "Ղ",
	["ճ"] = "Ճ",
	["մ"] = "Մ",
	["յ"] = "Յ",
	["ն"] = "Ն",
	["շ"] = "Շ",
	["ո"] = "Ո",
	["չ"] = "Չ",
	["պ"] = "Պ",
	["ջ"] = "Ջ",
	["ռ"] = "Ռ",
	["ս"] = "Ս",
	["վ"] = "Վ",
	["տ"] = "Տ",
	["ր"] = "Ր",
	["ց"] = "Ց",
	["ւ"] = "Ւ",
	["փ"] = "Փ",
	["ք"] = "Ք",
	["օ"] = "Օ",
	["ֆ"] = "Ֆ",
	["ᵽ"] = "Ᵽ",
	["ḁ"] = "Ḁ",
	["ḃ"] = "Ḃ",
	["ḅ"] = "Ḅ",
	["ḇ"] = "Ḇ",
	["ḉ"] = "Ḉ",
	["ḋ"] = "Ḋ",
	["ḍ"] = "Ḍ",
	["ḏ"] = "Ḏ",
	["ḑ"] = "Ḑ",
	["ḓ"] = "Ḓ",
	["ḕ"] = "Ḕ",
	["ḗ"] = "Ḗ",
	["ḙ"] = "Ḙ",
	["ḛ"] = "Ḛ",
	["ḝ"] = "Ḝ",
	["ḟ"] = "Ḟ",
	["ḡ"] = "Ḡ",
	["ḣ"] = "Ḣ",
	["ḥ"] = "Ḥ",
	["ḧ"] = "Ḧ",
	["ḩ"] = "Ḩ",
	["ḫ"] = "Ḫ",
	["ḭ"] = "Ḭ",
	["ḯ"] = "Ḯ",
	["ḱ"] = "Ḱ",
	["ḳ"] = "Ḳ",
	["ḵ"] = "Ḵ",
	["ḷ"] = "Ḷ",
	["ḹ"] = "Ḹ",
	["ḻ"] = "Ḻ",
	["ḽ"] = "Ḽ",
	["ḿ"] = "Ḿ",
	["ṁ"] = "Ṁ",
	["ṃ"] = "Ṃ",
	["ṅ"] = "Ṅ",
	["ṇ"] = "Ṇ",
	["ṉ"] = "Ṉ",
	["ṋ"] = "Ṋ",
	["ṍ"] = "Ṍ",
	["ṏ"] = "Ṏ",
	["ṑ"] = "Ṑ",
	["ṓ"] = "Ṓ",
	["ṕ"] = "Ṕ",
	["ṗ"] = "Ṗ",
	["ṙ"] = "Ṙ",
	["ṛ"] = "Ṛ",
	["ṝ"] = "Ṝ",
	["ṟ"] = "Ṟ",
	["ṡ"] = "Ṡ",
	["ṣ"] = "Ṣ",
	["ṥ"] = "Ṥ",
	["ṧ"] = "Ṧ",
	["ṩ"] = "Ṩ",
	["ṫ"] = "Ṫ",
	["ṭ"] = "Ṭ",
	["ṯ"] = "Ṯ",
	["ṱ"] = "Ṱ",
	["ṳ"] = "Ṳ",
	["ṵ"] = "Ṵ",
	["ṷ"] = "Ṷ",
	["ṹ"] = "Ṹ",
	["ṻ"] = "Ṻ",
	["ṽ"] = "Ṽ",
	["ṿ"] = "Ṿ",
	["ẁ"] = "Ẁ",
	["ẃ"] = "Ẃ",
	["ẅ"] = "Ẅ",
	["ẇ"] = "Ẇ",
	["ẉ"] = "Ẉ",
	["ẋ"] = "Ẋ",
	["ẍ"] = "Ẍ",
	["ẏ"] = "Ẏ",
	["ẑ"] = "Ẑ",
	["ẓ"] = "Ẓ",
	["ẕ"] = "Ẕ",
	["ẛ"] = "Ṡ",
	["ạ"] = "Ạ",
	["ả"] = "Ả",
	["ấ"] = "Ấ",
	["ầ"] = "Ầ",
	["ẩ"] = "Ẩ",
	["ẫ"] = "Ẫ",
	["ậ"] = "Ậ",
	["ắ"] = "Ắ",
	["ằ"] = "Ằ",
	["ẳ"] = "Ẳ",
	["ẵ"] = "Ẵ",
	["ặ"] = "Ặ",
	["ẹ"] = "Ẹ",
	["ẻ"] = "Ẻ",
	["ẽ"] = "Ẽ",
	["ế"] = "Ế",
	["ề"] = "Ề",
	["ể"] = "Ể",
	["ễ"] = "Ễ",
	["ệ"] = "Ệ",
	["ỉ"] = "Ỉ",
	["ị"] = "Ị",
	["ọ"] = "Ọ",
	["ỏ"] = "Ỏ",
	["ố"] = "Ố",
	["ồ"] = "Ồ",
	["ổ"] = "Ổ",
	["ỗ"] = "Ỗ",
	["ộ"] = "Ộ",
	["ớ"] = "Ớ",
	["ờ"] = "Ờ",
	["ở"] = "Ở",
	["ỡ"] = "Ỡ",
	["ợ"] = "Ợ",
	["ụ"] = "Ụ",
	["ủ"] = "Ủ",
	["ứ"] = "Ứ",
	["ừ"] = "Ừ",
	["ử"] = "Ử",
	["ữ"] = "Ữ",
	["ự"] = "Ự",
	["ỳ"] = "Ỳ",
	["ỵ"] = "Ỵ",
	["ỷ"] = "Ỷ",
	["ỹ"] = "Ỹ",
	["ἀ"] = "Ἀ",
	["ἁ"] = "Ἁ",
	["ἂ"] = "Ἂ",
	["ἃ"] = "Ἃ",
	["ἄ"] = "Ἄ",
	["ἅ"] = "Ἅ",
	["ἆ"] = "Ἆ",
	["ἇ"] = "Ἇ",
	["ἐ"] = "Ἐ",
	["ἑ"] = "Ἑ",
	["ἒ"] = "Ἒ",
	["ἓ"] = "Ἓ",
	["ἔ"] = "Ἔ",
	["ἕ"] = "Ἕ",
	["ἠ"] = "Ἠ",
	["ἡ"] = "Ἡ",
	["ἢ"] = "Ἢ",
	["ἣ"] = "Ἣ",
	["ἤ"] = "Ἤ",
	["ἥ"] = "Ἥ",
	["ἦ"] = "Ἦ",
	["ἧ"] = "Ἧ",
	["ἰ"] = "Ἰ",
	["ἱ"] = "Ἱ",
	["ἲ"] = "Ἲ",
	["ἳ"] = "Ἳ",
	["ἴ"] = "Ἴ",
	["ἵ"] = "Ἵ",
	["ἶ"] = "Ἶ",
	["ἷ"] = "Ἷ",
	["ὀ"] = "Ὀ",
	["ὁ"] = "Ὁ",
	["ὂ"] = "Ὂ",
	["ὃ"] = "Ὃ",
	["ὄ"] = "Ὄ",
	["ὅ"] = "Ὅ",
	["ὑ"] = "Ὑ",
	["ὓ"] = "Ὓ",
	["ὕ"] = "Ὕ",
	["ὗ"] = "Ὗ",
	["ὠ"] = "Ὠ",
	["ὡ"] = "Ὡ",
	["ὢ"] = "Ὢ",
	["ὣ"] = "Ὣ",
	["ὤ"] = "Ὤ",
	["ὥ"] = "Ὥ",
	["ὦ"] = "Ὦ",
	["ὧ"] = "Ὧ",
	["ὰ"] = "Ὰ",
	["ά"] = "Ά",
	["ὲ"] = "Ὲ",
	["έ"] = "Έ",
	["ὴ"] = "Ὴ",
	["ή"] = "Ή",
	["ὶ"] = "Ὶ",
	["ί"] = "Ί",
	["ὸ"] = "Ὸ",
	["ό"] = "Ό",
	["ὺ"] = "Ὺ",
	["ύ"] = "Ύ",
	["ὼ"] = "Ὼ",
	["ώ"] = "Ώ",
	["ᾀ"] = "ᾈ",
	["ᾁ"] = "ᾉ",
	["ᾂ"] = "ᾊ",
	["ᾃ"] = "ᾋ",
	["ᾄ"] = "ᾌ",
	["ᾅ"] = "ᾍ",
	["ᾆ"] = "ᾎ",
	["ᾇ"] = "ᾏ",
	["ᾐ"] = "ᾘ",
	["ᾑ"] = "ᾙ",
	["ᾒ"] = "ᾚ",
	["ᾓ"] = "ᾛ",
	["ᾔ"] = "ᾜ",
	["ᾕ"] = "ᾝ",
	["ᾖ"] = "ᾞ",
	["ᾗ"] = "ᾟ",
	["ᾠ"] = "ᾨ",
	["ᾡ"] = "ᾩ",
	["ᾢ"] = "ᾪ",
	["ᾣ"] = "ᾫ",
	["ᾤ"] = "ᾬ",
	["ᾥ"] = "ᾭ",
	["ᾦ"] = "ᾮ",
	["ᾧ"] = "ᾯ",
	["ᾰ"] = "Ᾰ",
	["ᾱ"] = "Ᾱ",
	["ᾳ"] = "ᾼ",
	["ι"] = "Ι",
	["ῃ"] = "ῌ",
	["ῐ"] = "Ῐ",
	["ῑ"] = "Ῑ",
	["ῠ"] = "Ῠ",
	["ῡ"] = "Ῡ",
	["ῥ"] = "Ῥ",
	["ῳ"] = "ῼ",
	["ⅎ"] = "Ⅎ",
	["ⅰ"] = "Ⅰ",
	["ⅱ"] = "Ⅱ",
	["ⅲ"] = "Ⅲ",
	["ⅳ"] = "Ⅳ",
	["ⅴ"] = "Ⅴ",
	["ⅵ"] = "Ⅵ",
	["ⅶ"] = "Ⅶ",
	["ⅷ"] = "Ⅷ",
	["ⅸ"] = "Ⅸ",
	["ⅹ"] = "Ⅹ",
	["ⅺ"] = "Ⅺ",
	["ⅻ"] = "Ⅻ",
	["ⅼ"] = "Ⅼ",
	["ⅽ"] = "Ⅽ",
	["ⅾ"] = "Ⅾ",
	["ⅿ"] = "Ⅿ",
	["ↄ"] = "Ↄ",
	["ⓐ"] = "Ⓐ",
	["ⓑ"] = "Ⓑ",
	["ⓒ"] = "Ⓒ",
	["ⓓ"] = "Ⓓ",
	["ⓔ"] = "Ⓔ",
	["ⓕ"] = "Ⓕ",
	["ⓖ"] = "Ⓖ",
	["ⓗ"] = "Ⓗ",
	["ⓘ"] = "Ⓘ",
	["ⓙ"] = "Ⓙ",
	["ⓚ"] = "Ⓚ",
	["ⓛ"] = "Ⓛ",
	["ⓜ"] = "Ⓜ",
	["ⓝ"] = "Ⓝ",
	["ⓞ"] = "Ⓞ",
	["ⓟ"] = "Ⓟ",
	["ⓠ"] = "Ⓠ",
	["ⓡ"] = "Ⓡ",
	["ⓢ"] = "Ⓢ",
	["ⓣ"] = "Ⓣ",
	["ⓤ"] = "Ⓤ",
	["ⓥ"] = "Ⓥ",
	["ⓦ"] = "Ⓦ",
	["ⓧ"] = "Ⓧ",
	["ⓨ"] = "Ⓨ",
	["ⓩ"] = "Ⓩ",
	["ⰰ"] = "Ⰰ",
	["ⰱ"] = "Ⰱ",
	["ⰲ"] = "Ⰲ",
	["ⰳ"] = "Ⰳ",
	["ⰴ"] = "Ⰴ",
	["ⰵ"] = "Ⰵ",
	["ⰶ"] = "Ⰶ",
	["ⰷ"] = "Ⰷ",
	["ⰸ"] = "Ⰸ",
	["ⰹ"] = "Ⰹ",
	["ⰺ"] = "Ⰺ",
	["ⰻ"] = "Ⰻ",
	["ⰼ"] = "Ⰼ",
	["ⰽ"] = "Ⰽ",
	["ⰾ"] = "Ⰾ",
	["ⰿ"] = "Ⰿ",
	["ⱀ"] = "Ⱀ",
	["ⱁ"] = "Ⱁ",
	["ⱂ"] = "Ⱂ",
	["ⱃ"] = "Ⱃ",
	["ⱄ"] = "Ⱄ",
	["ⱅ"] = "Ⱅ",
	["ⱆ"] = "Ⱆ",
	["ⱇ"] = "Ⱇ",
	["ⱈ"] = "Ⱈ",
	["ⱉ"] = "Ⱉ",
	["ⱊ"] = "Ⱊ",
	["ⱋ"] = "Ⱋ",
	["ⱌ"] = "Ⱌ",
	["ⱍ"] = "Ⱍ",
	["ⱎ"] = "Ⱎ",
	["ⱏ"] = "Ⱏ",
	["ⱐ"] = "Ⱐ",
	["ⱑ"] = "Ⱑ",
	["ⱒ"] = "Ⱒ",
	["ⱓ"] = "Ⱓ",
	["ⱔ"] = "Ⱔ",
	["ⱕ"] = "Ⱕ",
	["ⱖ"] = "Ⱖ",
	["ⱗ"] = "Ⱗ",
	["ⱘ"] = "Ⱘ",
	["ⱙ"] = "Ⱙ",
	["ⱚ"] = "Ⱚ",
	["ⱛ"] = "Ⱛ",
	["ⱜ"] = "Ⱜ",
	["ⱝ"] = "Ⱝ",
	["ⱞ"] = "Ⱞ",
	["ⱡ"] = "Ⱡ",
	["ⱥ"] = "Ⱥ",
	["ⱦ"] = "Ⱦ",
	["ⱨ"] = "Ⱨ",
	["ⱪ"] = "Ⱪ",
	["ⱬ"] = "Ⱬ",
	["ⱶ"] = "Ⱶ",
	["ⲁ"] = "Ⲁ",
	["ⲃ"] = "Ⲃ",
	["ⲅ"] = "Ⲅ",
	["ⲇ"] = "Ⲇ",
	["ⲉ"] = "Ⲉ",
	["ⲋ"] = "Ⲋ",
	["ⲍ"] = "Ⲍ",
	["ⲏ"] = "Ⲏ",
	["ⲑ"] = "Ⲑ",
	["ⲓ"] = "Ⲓ",
	["ⲕ"] = "Ⲕ",
	["ⲗ"] = "Ⲗ",
	["ⲙ"] = "Ⲙ",
	["ⲛ"] = "Ⲛ",
	["ⲝ"] = "Ⲝ",
	["ⲟ"] = "Ⲟ",
	["ⲡ"] = "Ⲡ",
	["ⲣ"] = "Ⲣ",
	["ⲥ"] = "Ⲥ",
	["ⲧ"] = "Ⲧ",
	["ⲩ"] = "Ⲩ",
	["ⲫ"] = "Ⲫ",
	["ⲭ"] = "Ⲭ",
	["ⲯ"] = "Ⲯ",
	["ⲱ"] = "Ⲱ",
	["ⲳ"] = "Ⲳ",
	["ⲵ"] = "Ⲵ",
	["ⲷ"] = "Ⲷ",
	["ⲹ"] = "Ⲹ",
	["ⲻ"] = "Ⲻ",
	["ⲽ"] = "Ⲽ",
	["ⲿ"] = "Ⲿ",
	["ⳁ"] = "Ⳁ",
	["ⳃ"] = "Ⳃ",
	["ⳅ"] = "Ⳅ",
	["ⳇ"] = "Ⳇ",
	["ⳉ"] = "Ⳉ",
	["ⳋ"] = "Ⳋ",
	["ⳍ"] = "Ⳍ",
	["ⳏ"] = "Ⳏ",
	["ⳑ"] = "Ⳑ",
	["ⳓ"] = "Ⳓ",
	["ⳕ"] = "Ⳕ",
	["ⳗ"] = "Ⳗ",
	["ⳙ"] = "Ⳙ",
	["ⳛ"] = "Ⳛ",
	["ⳝ"] = "Ⳝ",
	["ⳟ"] = "Ⳟ",
	["ⳡ"] = "Ⳡ",
	["ⳣ"] = "Ⳣ",
	["ⴀ"] = "Ⴀ",
	["ⴁ"] = "Ⴁ",
	["ⴂ"] = "Ⴂ",
	["ⴃ"] = "Ⴃ",
	["ⴄ"] = "Ⴄ",
	["ⴅ"] = "Ⴅ",
	["ⴆ"] = "Ⴆ",
	["ⴇ"] = "Ⴇ",
	["ⴈ"] = "Ⴈ",
	["ⴉ"] = "Ⴉ",
	["ⴊ"] = "Ⴊ",
	["ⴋ"] = "Ⴋ",
	["ⴌ"] = "Ⴌ",
	["ⴍ"] = "Ⴍ",
	["ⴎ"] = "Ⴎ",
	["ⴏ"] = "Ⴏ",
	["ⴐ"] = "Ⴐ",
	["ⴑ"] = "Ⴑ",
	["ⴒ"] = "Ⴒ",
	["ⴓ"] = "Ⴓ",
	["ⴔ"] = "Ⴔ",
	["ⴕ"] = "Ⴕ",
	["ⴖ"] = "Ⴖ",
	["ⴗ"] = "Ⴗ",
	["ⴘ"] = "Ⴘ",
	["ⴙ"] = "Ⴙ",
	["ⴚ"] = "Ⴚ",
	["ⴛ"] = "Ⴛ",
	["ⴜ"] = "Ⴜ",
	["ⴝ"] = "Ⴝ",
	["ⴞ"] = "Ⴞ",
	["ⴟ"] = "Ⴟ",
	["ⴠ"] = "Ⴠ",
	["ⴡ"] = "Ⴡ",
	["ⴢ"] = "Ⴢ",
	["ⴣ"] = "Ⴣ",
	["ⴤ"] = "Ⴤ",
	["ⴥ"] = "Ⴥ",
	["ａ"] = "Ａ",
	["ｂ"] = "Ｂ",
	["ｃ"] = "Ｃ",
	["ｄ"] = "Ｄ",
	["ｅ"] = "Ｅ",
	["ｆ"] = "Ｆ",
	["ｇ"] = "Ｇ",
	["ｈ"] = "Ｈ",
	["ｉ"] = "Ｉ",
	["ｊ"] = "Ｊ",
	["ｋ"] = "Ｋ",
	["ｌ"] = "Ｌ",
	["ｍ"] = "Ｍ",
	["ｎ"] = "Ｎ",
	["ｏ"] = "Ｏ",
	["ｐ"] = "Ｐ",
	["ｑ"] = "Ｑ",
	["ｒ"] = "Ｒ",
	["ｓ"] = "Ｓ",
	["ｔ"] = "Ｔ",
	["ｕ"] = "Ｕ",
	["ｖ"] = "Ｖ",
	["ｗ"] = "Ｗ",
	["ｘ"] = "Ｘ",
	["ｙ"] = "Ｙ",
	["ｚ"] = "Ｚ",
	["𐐨"] = "𐐀",
	["𐐩"] = "𐐁",
	["𐐪"] = "𐐂",
	["𐐫"] = "𐐃",
	["𐐬"] = "𐐄",
	["𐐭"] = "𐐅",
	["𐐮"] = "𐐆",
	["𐐯"] = "𐐇",
	["𐐰"] = "𐐈",
	["𐐱"] = "𐐉",
	["𐐲"] = "𐐊",
	["𐐳"] = "𐐋",
	["𐐴"] = "𐐌",
	["𐐵"] = "𐐍",
	["𐐶"] = "𐐎",
	["𐐷"] = "𐐏",
	["𐐸"] = "𐐐",
	["𐐹"] = "𐐑",
	["𐐺"] = "𐐒",
	["𐐻"] = "𐐓",
	["𐐼"] = "𐐔",
	["𐐽"] = "𐐕",
	["𐐾"] = "𐐖",
	["𐐿"] = "𐐗",
	["𐑀"] = "𐐘",
	["𐑁"] = "𐐙",
	["𐑂"] = "𐐚",
	["𐑃"] = "𐐛",
	["𐑄"] = "𐐜",
	["𐑅"] = "𐐝",
	["𐑆"] = "𐐞",
	["𐑇"] = "𐐟",
	["𐑈"] = "𐐠",
	["𐑉"] = "𐐡",
	["𐑊"] = "𐐢",
	["𐑋"] = "𐐣",
	["𐑌"] = "𐐤",
	["𐑍"] = "𐐥",
	["𐑎"] = "𐐦",
	["𐑏"] = "𐐧",
}

utf8_uc_lc = {
	["A"] = "a",
	["B"] = "b",
	["C"] = "c",
	["D"] = "d",
	["E"] = "e",
	["F"] = "f",
	["G"] = "g",
	["H"] = "h",
	["I"] = "i",
	["J"] = "j",
	["K"] = "k",
	["L"] = "l",
	["M"] = "m",
	["N"] = "n",
	["O"] = "o",
	["P"] = "p",
	["Q"] = "q",
	["R"] = "r",
	["S"] = "s",
	["T"] = "t",
	["U"] = "u",
	["V"] = "v",
	["W"] = "w",
	["X"] = "x",
	["Y"] = "y",
	["Z"] = "z",
	["À"] = "à",
	["Á"] = "á",
	["Â"] = "â",
	["Ã"] = "ã",
	["Ä"] = "ä",
	["Å"] = "å",
	["Æ"] = "æ",
	["Ç"] = "ç",
	["È"] = "è",
	["É"] = "é",
	["Ê"] = "ê",
	["Ë"] = "ë",
	["Ì"] = "ì",
	["Í"] = "í",
	["Î"] = "î",
	["Ï"] = "ï",
	["Ð"] = "ð",
	["Ñ"] = "ñ",
	["Ò"] = "ò",
	["Ó"] = "ó",
	["Ô"] = "ô",
	["Õ"] = "õ",
	["Ö"] = "ö",
	["Ø"] = "ø",
	["Ù"] = "ù",
	["Ú"] = "ú",
	["Û"] = "û",
	["Ü"] = "ü",
	["Ý"] = "ý",
	["Þ"] = "þ",
	["Ā"] = "ā",
	["Ă"] = "ă",
	["Ą"] = "ą",
	["Ć"] = "ć",
	["Ĉ"] = "ĉ",
	["Ċ"] = "ċ",
	["Č"] = "č",
	["Ď"] = "ď",
	["Đ"] = "đ",
	["Ē"] = "ē",
	["Ĕ"] = "ĕ",
	["Ė"] = "ė",
	["Ę"] = "ę",
	["Ě"] = "ě",
	["Ĝ"] = "ĝ",
	["Ğ"] = "ğ",
	["Ġ"] = "ġ",
	["Ģ"] = "ģ",
	["Ĥ"] = "ĥ",
	["Ħ"] = "ħ",
	["Ĩ"] = "ĩ",
	["Ī"] = "ī",
	["Ĭ"] = "ĭ",
	["Į"] = "į",
	["İ"] = "i",
	["Ĳ"] = "ĳ",
	["Ĵ"] = "ĵ",
	["Ķ"] = "ķ",
	["Ĺ"] = "ĺ",
	["Ļ"] = "ļ",
	["Ľ"] = "ľ",
	["Ŀ"] = "ŀ",
	["Ł"] = "ł",
	["Ń"] = "ń",
	["Ņ"] = "ņ",
	["Ň"] = "ň",
	["Ŋ"] = "ŋ",
	["Ō"] = "ō",
	["Ŏ"] = "ŏ",
	["Ő"] = "ő",
	["Œ"] = "œ",
	["Ŕ"] = "ŕ",
	["Ŗ"] = "ŗ",
	["Ř"] = "ř",
	["Ś"] = "ś",
	["Ŝ"] = "ŝ",
	["Ş"] = "ş",
	["Š"] = "š",
	["Ţ"] = "ţ",
	["Ť"] = "ť",
	["Ŧ"] = "ŧ",
	["Ũ"] = "ũ",
	["Ū"] = "ū",
	["Ŭ"] = "ŭ",
	["Ů"] = "ů",
	["Ű"] = "ű",
	["Ų"] = "ų",
	["Ŵ"] = "ŵ",
	["Ŷ"] = "ŷ",
	["Ÿ"] = "ÿ",
	["Ź"] = "ź",
	["Ż"] = "ż",
	["Ž"] = "ž",
	["Ɓ"] = "ɓ",
	["Ƃ"] = "ƃ",
	["Ƅ"] = "ƅ",
	["Ɔ"] = "ɔ",
	["Ƈ"] = "ƈ",
	["Ɖ"] = "ɖ",
	["Ɗ"] = "ɗ",
	["Ƌ"] = "ƌ",
	["Ǝ"] = "ǝ",
	["Ə"] = "ə",
	["Ɛ"] = "ɛ",
	["Ƒ"] = "ƒ",
	["Ɠ"] = "ɠ",
	["Ɣ"] = "ɣ",
	["Ɩ"] = "ɩ",
	["Ɨ"] = "ɨ",
	["Ƙ"] = "ƙ",
	["Ɯ"] = "ɯ",
	["Ɲ"] = "ɲ",
	["Ɵ"] = "ɵ",
	["Ơ"] = "ơ",
	["Ƣ"] = "ƣ",
	["Ƥ"] = "ƥ",
	["Ʀ"] = "ʀ",
	["Ƨ"] = "ƨ",
	["Ʃ"] = "ʃ",
	["Ƭ"] = "ƭ",
	["Ʈ"] = "ʈ",
	["Ư"] = "ư",
	["Ʊ"] = "ʊ",
	["Ʋ"] = "ʋ",
	["Ƴ"] = "ƴ",
	["Ƶ"] = "ƶ",
	["Ʒ"] = "ʒ",
	["Ƹ"] = "ƹ",
	["Ƽ"] = "ƽ",
	["Ǆ"] = "ǆ",
	["ǅ"] = "ǆ",
	["Ǉ"] = "ǉ",
	["ǈ"] = "ǉ",
	["Ǌ"] = "ǌ",
	["ǋ"] = "ǌ",
	["Ǎ"] = "ǎ",
	["Ǐ"] = "ǐ",
	["Ǒ"] = "ǒ",
	["Ǔ"] = "ǔ",
	["Ǖ"] = "ǖ",
	["Ǘ"] = "ǘ",
	["Ǚ"] = "ǚ",
	["Ǜ"] = "ǜ",
	["Ǟ"] = "ǟ",
	["Ǡ"] = "ǡ",
	["Ǣ"] = "ǣ",
	["Ǥ"] = "ǥ",
	["Ǧ"] = "ǧ",
	["Ǩ"] = "ǩ",
	["Ǫ"] = "ǫ",
	["Ǭ"] = "ǭ",
	["Ǯ"] = "ǯ",
	["Ǳ"] = "ǳ",
	["ǲ"] = "ǳ",
	["Ǵ"] = "ǵ",
	["Ƕ"] = "ƕ",
	["Ƿ"] = "ƿ",
	["Ǹ"] = "ǹ",
	["Ǻ"] = "ǻ",
	["Ǽ"] = "ǽ",
	["Ǿ"] = "ǿ",
	["Ȁ"] = "ȁ",
	["Ȃ"] = "ȃ",
	["Ȅ"] = "ȅ",
	["Ȇ"] = "ȇ",
	["Ȉ"] = "ȉ",
	["Ȋ"] = "ȋ",
	["Ȍ"] = "ȍ",
	["Ȏ"] = "ȏ",
	["Ȑ"] = "ȑ",
	["Ȓ"] = "ȓ",
	["Ȕ"] = "ȕ",
	["Ȗ"] = "ȗ",
	["Ș"] = "ș",
	["Ț"] = "ț",
	["Ȝ"] = "ȝ",
	["Ȟ"] = "ȟ",
	["Ƞ"] = "ƞ",
	["Ȣ"] = "ȣ",
	["Ȥ"] = "ȥ",
	["Ȧ"] = "ȧ",
	["Ȩ"] = "ȩ",
	["Ȫ"] = "ȫ",
	["Ȭ"] = "ȭ",
	["Ȯ"] = "ȯ",
	["Ȱ"] = "ȱ",
	["Ȳ"] = "ȳ",
	["Ⱥ"] = "ⱥ",
	["Ȼ"] = "ȼ",
	["Ƚ"] = "ƚ",
	["Ⱦ"] = "ⱦ",
	["Ɂ"] = "ɂ",
	["Ƀ"] = "ƀ",
	["Ʉ"] = "ʉ",
	["Ʌ"] = "ʌ",
	["Ɇ"] = "ɇ",
	["Ɉ"] = "ɉ",
	["Ɋ"] = "ɋ",
	["Ɍ"] = "ɍ",
	["Ɏ"] = "ɏ",
	["Ά"] = "ά",
	["Έ"] = "έ",
	["Ή"] = "ή",
	["Ί"] = "ί",
	["Ό"] = "ό",
	["Ύ"] = "ύ",
	["Ώ"] = "ώ",
	["Α"] = "α",
	["Β"] = "β",
	["Γ"] = "γ",
	["Δ"] = "δ",
	["Ε"] = "ε",
	["Ζ"] = "ζ",
	["Η"] = "η",
	["Θ"] = "θ",
	["Ι"] = "ι",
	["Κ"] = "κ",
	["Λ"] = "λ",
	["Μ"] = "μ",
	["Ν"] = "ν",
	["Ξ"] = "ξ",
	["Ο"] = "ο",
	["Π"] = "π",
	["Ρ"] = "ρ",
	["Σ"] = "σ",
	["Τ"] = "τ",
	["Υ"] = "υ",
	["Φ"] = "φ",
	["Χ"] = "χ",
	["Ψ"] = "ψ",
	["Ω"] = "ω",
	["Ϊ"] = "ϊ",
	["Ϋ"] = "ϋ",
	["Ϙ"] = "ϙ",
	["Ϛ"] = "ϛ",
	["Ϝ"] = "ϝ",
	["Ϟ"] = "ϟ",
	["Ϡ"] = "ϡ",
	["Ϣ"] = "ϣ",
	["Ϥ"] = "ϥ",
	["Ϧ"] = "ϧ",
	["Ϩ"] = "ϩ",
	["Ϫ"] = "ϫ",
	["Ϭ"] = "ϭ",
	["Ϯ"] = "ϯ",
	["ϴ"] = "θ",
	["Ϸ"] = "ϸ",
	["Ϲ"] = "ϲ",
	["Ϻ"] = "ϻ",
	["Ͻ"] = "ͻ",
	["Ͼ"] = "ͼ",
	["Ͽ"] = "ͽ",
	["Ѐ"] = "ѐ",
	["Ё"] = "ё",
	["Ђ"] = "ђ",
	["Ѓ"] = "ѓ",
	["Є"] = "є",
	["Ѕ"] = "ѕ",
	["І"] = "і",
	["Ї"] = "ї",
	["Ј"] = "ј",
	["Љ"] = "љ",
	["Њ"] = "њ",
	["Ћ"] = "ћ",
	["Ќ"] = "ќ",
	["Ѝ"] = "ѝ",
	["Ў"] = "ў",
	["Џ"] = "џ",
	["А"] = "а",
	["Б"] = "б",
	["В"] = "в",
	["Г"] = "г",
	["Д"] = "д",
	["Е"] = "е",
	["Ж"] = "ж",
	["З"] = "з",
	["И"] = "и",
	["Й"] = "й",
	["К"] = "к",
	["Л"] = "л",
	["М"] = "м",
	["Н"] = "н",
	["О"] = "о",
	["П"] = "п",
	["Р"] = "р",
	["С"] = "с",
	["Т"] = "т",
	["У"] = "у",
	["Ф"] = "ф",
	["Х"] = "х",
	["Ц"] = "ц",
	["Ч"] = "ч",
	["Ш"] = "ш",
	["Щ"] = "щ",
	["Ъ"] = "ъ",
	["Ы"] = "ы",
	["Ь"] = "ь",
	["Э"] = "э",
	["Ю"] = "ю",
	["Я"] = "я",
	["Ѡ"] = "ѡ",
	["Ѣ"] = "ѣ",
	["Ѥ"] = "ѥ",
	["Ѧ"] = "ѧ",
	["Ѩ"] = "ѩ",
	["Ѫ"] = "ѫ",
	["Ѭ"] = "ѭ",
	["Ѯ"] = "ѯ",
	["Ѱ"] = "ѱ",
	["Ѳ"] = "ѳ",
	["Ѵ"] = "ѵ",
	["Ѷ"] = "ѷ",
	["Ѹ"] = "ѹ",
	["Ѻ"] = "ѻ",
	["Ѽ"] = "ѽ",
	["Ѿ"] = "ѿ",
	["Ҁ"] = "ҁ",
	["Ҋ"] = "ҋ",
	["Ҍ"] = "ҍ",
	["Ҏ"] = "ҏ",
	["Ґ"] = "ґ",
	["Ғ"] = "ғ",
	["Ҕ"] = "ҕ",
	["Җ"] = "җ",
	["Ҙ"] = "ҙ",
	["Қ"] = "қ",
	["Ҝ"] = "ҝ",
	["Ҟ"] = "ҟ",
	["Ҡ"] = "ҡ",
	["Ң"] = "ң",
	["Ҥ"] = "ҥ",
	["Ҧ"] = "ҧ",
	["Ҩ"] = "ҩ",
	["Ҫ"] = "ҫ",
	["Ҭ"] = "ҭ",
	["Ү"] = "ү",
	["Ұ"] = "ұ",
	["Ҳ"] = "ҳ",
	["Ҵ"] = "ҵ",
	["Ҷ"] = "ҷ",
	["Ҹ"] = "ҹ",
	["Һ"] = "һ",
	["Ҽ"] = "ҽ",
	["Ҿ"] = "ҿ",
	["Ӏ"] = "ӏ",
	["Ӂ"] = "ӂ",
	["Ӄ"] = "ӄ",
	["Ӆ"] = "ӆ",
	["Ӈ"] = "ӈ",
	["Ӊ"] = "ӊ",
	["Ӌ"] = "ӌ",
	["Ӎ"] = "ӎ",
	["Ӑ"] = "ӑ",
	["Ӓ"] = "ӓ",
	["Ӕ"] = "ӕ",
	["Ӗ"] = "ӗ",
	["Ә"] = "ә",
	["Ӛ"] = "ӛ",
	["Ӝ"] = "ӝ",
	["Ӟ"] = "ӟ",
	["Ӡ"] = "ӡ",
	["Ӣ"] = "ӣ",
	["Ӥ"] = "ӥ",
	["Ӧ"] = "ӧ",
	["Ө"] = "ө",
	["Ӫ"] = "ӫ",
	["Ӭ"] = "ӭ",
	["Ӯ"] = "ӯ",
	["Ӱ"] = "ӱ",
	["Ӳ"] = "ӳ",
	["Ӵ"] = "ӵ",
	["Ӷ"] = "ӷ",
	["Ӹ"] = "ӹ",
	["Ӻ"] = "ӻ",
	["Ӽ"] = "ӽ",
	["Ӿ"] = "ӿ",
	["Ԁ"] = "ԁ",
	["Ԃ"] = "ԃ",
	["Ԅ"] = "ԅ",
	["Ԇ"] = "ԇ",
	["Ԉ"] = "ԉ",
	["Ԋ"] = "ԋ",
	["Ԍ"] = "ԍ",
	["Ԏ"] = "ԏ",
	["Ԑ"] = "ԑ",
	["Ԓ"] = "ԓ",
	["Ա"] = "ա",
	["Բ"] = "բ",
	["Գ"] = "գ",
	["Դ"] = "դ",
	["Ե"] = "ե",
	["Զ"] = "զ",
	["Է"] = "է",
	["Ը"] = "ը",
	["Թ"] = "թ",
	["Ժ"] = "ժ",
	["Ի"] = "ի",
	["Լ"] = "լ",
	["Խ"] = "խ",
	["Ծ"] = "ծ",
	["Կ"] = "կ",
	["Հ"] = "հ",
	["Ձ"] = "ձ",
	["Ղ"] = "ղ",
	["Ճ"] = "ճ",
	["Մ"] = "մ",
	["Յ"] = "յ",
	["Ն"] = "ն",
	["Շ"] = "շ",
	["Ո"] = "ո",
	["Չ"] = "չ",
	["Պ"] = "պ",
	["Ջ"] = "ջ",
	["Ռ"] = "ռ",
	["Ս"] = "ս",
	["Վ"] = "վ",
	["Տ"] = "տ",
	["Ր"] = "ր",
	["Ց"] = "ց",
	["Ւ"] = "ւ",
	["Փ"] = "փ",
	["Ք"] = "ք",
	["Օ"] = "օ",
	["Ֆ"] = "ֆ",
	["Ⴀ"] = "ⴀ",
	["Ⴁ"] = "ⴁ",
	["Ⴂ"] = "ⴂ",
	["Ⴃ"] = "ⴃ",
	["Ⴄ"] = "ⴄ",
	["Ⴅ"] = "ⴅ",
	["Ⴆ"] = "ⴆ",
	["Ⴇ"] = "ⴇ",
	["Ⴈ"] = "ⴈ",
	["Ⴉ"] = "ⴉ",
	["Ⴊ"] = "ⴊ",
	["Ⴋ"] = "ⴋ",
	["Ⴌ"] = "ⴌ",
	["Ⴍ"] = "ⴍ",
	["Ⴎ"] = "ⴎ",
	["Ⴏ"] = "ⴏ",
	["Ⴐ"] = "ⴐ",
	["Ⴑ"] = "ⴑ",
	["Ⴒ"] = "ⴒ",
	["Ⴓ"] = "ⴓ",
	["Ⴔ"] = "ⴔ",
	["Ⴕ"] = "ⴕ",
	["Ⴖ"] = "ⴖ",
	["Ⴗ"] = "ⴗ",
	["Ⴘ"] = "ⴘ",
	["Ⴙ"] = "ⴙ",
	["Ⴚ"] = "ⴚ",
	["Ⴛ"] = "ⴛ",
	["Ⴜ"] = "ⴜ",
	["Ⴝ"] = "ⴝ",
	["Ⴞ"] = "ⴞ",
	["Ⴟ"] = "ⴟ",
	["Ⴠ"] = "ⴠ",
	["Ⴡ"] = "ⴡ",
	["Ⴢ"] = "ⴢ",
	["Ⴣ"] = "ⴣ",
	["Ⴤ"] = "ⴤ",
	["Ⴥ"] = "ⴥ",
	["Ḁ"] = "ḁ",
	["Ḃ"] = "ḃ",
	["Ḅ"] = "ḅ",
	["Ḇ"] = "ḇ",
	["Ḉ"] = "ḉ",
	["Ḋ"] = "ḋ",
	["Ḍ"] = "ḍ",
	["Ḏ"] = "ḏ",
	["Ḑ"] = "ḑ",
	["Ḓ"] = "ḓ",
	["Ḕ"] = "ḕ",
	["Ḗ"] = "ḗ",
	["Ḙ"] = "ḙ",
	["Ḛ"] = "ḛ",
	["Ḝ"] = "ḝ",
	["Ḟ"] = "ḟ",
	["Ḡ"] = "ḡ",
	["Ḣ"] = "ḣ",
	["Ḥ"] = "ḥ",
	["Ḧ"] = "ḧ",
	["Ḩ"] = "ḩ",
	["Ḫ"] = "ḫ",
	["Ḭ"] = "ḭ",
	["Ḯ"] = "ḯ",
	["Ḱ"] = "ḱ",
	["Ḳ"] = "ḳ",
	["Ḵ"] = "ḵ",
	["Ḷ"] = "ḷ",
	["Ḹ"] = "ḹ",
	["Ḻ"] = "ḻ",
	["Ḽ"] = "ḽ",
	["Ḿ"] = "ḿ",
	["Ṁ"] = "ṁ",
	["Ṃ"] = "ṃ",
	["Ṅ"] = "ṅ",
	["Ṇ"] = "ṇ",
	["Ṉ"] = "ṉ",
	["Ṋ"] = "ṋ",
	["Ṍ"] = "ṍ",
	["Ṏ"] = "ṏ",
	["Ṑ"] = "ṑ",
	["Ṓ"] = "ṓ",
	["Ṕ"] = "ṕ",
	["Ṗ"] = "ṗ",
	["Ṙ"] = "ṙ",
	["Ṛ"] = "ṛ",
	["Ṝ"] = "ṝ",
	["Ṟ"] = "ṟ",
	["Ṡ"] = "ṡ",
	["Ṣ"] = "ṣ",
	["Ṥ"] = "ṥ",
	["Ṧ"] = "ṧ",
	["Ṩ"] = "ṩ",
	["Ṫ"] = "ṫ",
	["Ṭ"] = "ṭ",
	["Ṯ"] = "ṯ",
	["Ṱ"] = "ṱ",
	["Ṳ"] = "ṳ",
	["Ṵ"] = "ṵ",
	["Ṷ"] = "ṷ",
	["Ṹ"] = "ṹ",
	["Ṻ"] = "ṻ",
	["Ṽ"] = "ṽ",
	["Ṿ"] = "ṿ",
	["Ẁ"] = "ẁ",
	["Ẃ"] = "ẃ",
	["Ẅ"] = "ẅ",
	["Ẇ"] = "ẇ",
	["Ẉ"] = "ẉ",
	["Ẋ"] = "ẋ",
	["Ẍ"] = "ẍ",
	["Ẏ"] = "ẏ",
	["Ẑ"] = "ẑ",
	["Ẓ"] = "ẓ",
	["Ẕ"] = "ẕ",
	["Ạ"] = "ạ",
	["Ả"] = "ả",
	["Ấ"] = "ấ",
	["Ầ"] = "ầ",
	["Ẩ"] = "ẩ",
	["Ẫ"] = "ẫ",
	["Ậ"] = "ậ",
	["Ắ"] = "ắ",
	["Ằ"] = "ằ",
	["Ẳ"] = "ẳ",
	["Ẵ"] = "ẵ",
	["Ặ"] = "ặ",
	["Ẹ"] = "ẹ",
	["Ẻ"] = "ẻ",
	["Ẽ"] = "ẽ",
	["Ế"] = "ế",
	["Ề"] = "ề",
	["Ể"] = "ể",
	["Ễ"] = "ễ",
	["Ệ"] = "ệ",
	["Ỉ"] = "ỉ",
	["Ị"] = "ị",
	["Ọ"] = "ọ",
	["Ỏ"] = "ỏ",
	["Ố"] = "ố",
	["Ồ"] = "ồ",
	["Ổ"] = "ổ",
	["Ỗ"] = "ỗ",
	["Ộ"] = "ộ",
	["Ớ"] = "ớ",
	["Ờ"] = "ờ",
	["Ở"] = "ở",
	["Ỡ"] = "ỡ",
	["Ợ"] = "ợ",
	["Ụ"] = "ụ",
	["Ủ"] = "ủ",
	["Ứ"] = "ứ",
	["Ừ"] = "ừ",
	["Ử"] = "ử",
	["Ữ"] = "ữ",
	["Ự"] = "ự",
	["Ỳ"] = "ỳ",
	["Ỵ"] = "ỵ",
	["Ỷ"] = "ỷ",
	["Ỹ"] = "ỹ",
	["Ἀ"] = "ἀ",
	["Ἁ"] = "ἁ",
	["Ἂ"] = "ἂ",
	["Ἃ"] = "ἃ",
	["Ἄ"] = "ἄ",
	["Ἅ"] = "ἅ",
	["Ἆ"] = "ἆ",
	["Ἇ"] = "ἇ",
	["Ἐ"] = "ἐ",
	["Ἑ"] = "ἑ",
	["Ἒ"] = "ἒ",
	["Ἓ"] = "ἓ",
	["Ἔ"] = "ἔ",
	["Ἕ"] = "ἕ",
	["Ἠ"] = "ἠ",
	["Ἡ"] = "ἡ",
	["Ἢ"] = "ἢ",
	["Ἣ"] = "ἣ",
	["Ἤ"] = "ἤ",
	["Ἥ"] = "ἥ",
	["Ἦ"] = "ἦ",
	["Ἧ"] = "ἧ",
	["Ἰ"] = "ἰ",
	["Ἱ"] = "ἱ",
	["Ἲ"] = "ἲ",
	["Ἳ"] = "ἳ",
	["Ἴ"] = "ἴ",
	["Ἵ"] = "ἵ",
	["Ἶ"] = "ἶ",
	["Ἷ"] = "ἷ",
	["Ὀ"] = "ὀ",
	["Ὁ"] = "ὁ",
	["Ὂ"] = "ὂ",
	["Ὃ"] = "ὃ",
	["Ὄ"] = "ὄ",
	["Ὅ"] = "ὅ",
	["Ὑ"] = "ὑ",
	["Ὓ"] = "ὓ",
	["Ὕ"] = "ὕ",
	["Ὗ"] = "ὗ",
	["Ὠ"] = "ὠ",
	["Ὡ"] = "ὡ",
	["Ὢ"] = "ὢ",
	["Ὣ"] = "ὣ",
	["Ὤ"] = "ὤ",
	["Ὥ"] = "ὥ",
	["Ὦ"] = "ὦ",
	["Ὧ"] = "ὧ",
	["ᾈ"] = "ᾀ",
	["ᾉ"] = "ᾁ",
	["ᾊ"] = "ᾂ",
	["ᾋ"] = "ᾃ",
	["ᾌ"] = "ᾄ",
	["ᾍ"] = "ᾅ",
	["ᾎ"] = "ᾆ",
	["ᾏ"] = "ᾇ",
	["ᾘ"] = "ᾐ",
	["ᾙ"] = "ᾑ",
	["ᾚ"] = "ᾒ",
	["ᾛ"] = "ᾓ",
	["ᾜ"] = "ᾔ",
	["ᾝ"] = "ᾕ",
	["ᾞ"] = "ᾖ",
	["ᾟ"] = "ᾗ",
	["ᾨ"] = "ᾠ",
	["ᾩ"] = "ᾡ",
	["ᾪ"] = "ᾢ",
	["ᾫ"] = "ᾣ",
	["ᾬ"] = "ᾤ",
	["ᾭ"] = "ᾥ",
	["ᾮ"] = "ᾦ",
	["ᾯ"] = "ᾧ",
	["Ᾰ"] = "ᾰ",
	["Ᾱ"] = "ᾱ",
	["Ὰ"] = "ὰ",
	["Ά"] = "ά",
	["ᾼ"] = "ᾳ",
	["Ὲ"] = "ὲ",
	["Έ"] = "έ",
	["Ὴ"] = "ὴ",
	["Ή"] = "ή",
	["ῌ"] = "ῃ",
	["Ῐ"] = "ῐ",
	["Ῑ"] = "ῑ",
	["Ὶ"] = "ὶ",
	["Ί"] = "ί",
	["Ῠ"] = "ῠ",
	["Ῡ"] = "ῡ",
	["Ὺ"] = "ὺ",
	["Ύ"] = "ύ",
	["Ῥ"] = "ῥ",
	["Ὸ"] = "ὸ",
	["Ό"] = "ό",
	["Ὼ"] = "ὼ",
	["Ώ"] = "ώ",
	["ῼ"] = "ῳ",
	["Ω"] = "ω",
	["K"] = "k",
	["Å"] = "å",
	["Ⅎ"] = "ⅎ",
	["Ⅰ"] = "ⅰ",
	["Ⅱ"] = "ⅱ",
	["Ⅲ"] = "ⅲ",
	["Ⅳ"] = "ⅳ",
	["Ⅴ"] = "ⅴ",
	["Ⅵ"] = "ⅵ",
	["Ⅶ"] = "ⅶ",
	["Ⅷ"] = "ⅷ",
	["Ⅸ"] = "ⅸ",
	["Ⅹ"] = "ⅹ",
	["Ⅺ"] = "ⅺ",
	["Ⅻ"] = "ⅻ",
	["Ⅼ"] = "ⅼ",
	["Ⅽ"] = "ⅽ",
	["Ⅾ"] = "ⅾ",
	["Ⅿ"] = "ⅿ",
	["Ↄ"] = "ↄ",
	["Ⓐ"] = "ⓐ",
	["Ⓑ"] = "ⓑ",
	["Ⓒ"] = "ⓒ",
	["Ⓓ"] = "ⓓ",
	["Ⓔ"] = "ⓔ",
	["Ⓕ"] = "ⓕ",
	["Ⓖ"] = "ⓖ",
	["Ⓗ"] = "ⓗ",
	["Ⓘ"] = "ⓘ",
	["Ⓙ"] = "ⓙ",
	["Ⓚ"] = "ⓚ",
	["Ⓛ"] = "ⓛ",
	["Ⓜ"] = "ⓜ",
	["Ⓝ"] = "ⓝ",
	["Ⓞ"] = "ⓞ",
	["Ⓟ"] = "ⓟ",
	["Ⓠ"] = "ⓠ",
	["Ⓡ"] = "ⓡ",
	["Ⓢ"] = "ⓢ",
	["Ⓣ"] = "ⓣ",
	["Ⓤ"] = "ⓤ",
	["Ⓥ"] = "ⓥ",
	["Ⓦ"] = "ⓦ",
	["Ⓧ"] = "ⓧ",
	["Ⓨ"] = "ⓨ",
	["Ⓩ"] = "ⓩ",
	["Ⰰ"] = "ⰰ",
	["Ⰱ"] = "ⰱ",
	["Ⰲ"] = "ⰲ",
	["Ⰳ"] = "ⰳ",
	["Ⰴ"] = "ⰴ",
	["Ⰵ"] = "ⰵ",
	["Ⰶ"] = "ⰶ",
	["Ⰷ"] = "ⰷ",
	["Ⰸ"] = "ⰸ",
	["Ⰹ"] = "ⰹ",
	["Ⰺ"] = "ⰺ",
	["Ⰻ"] = "ⰻ",
	["Ⰼ"] = "ⰼ",
	["Ⰽ"] = "ⰽ",
	["Ⰾ"] = "ⰾ",
	["Ⰿ"] = "ⰿ",
	["Ⱀ"] = "ⱀ",
	["Ⱁ"] = "ⱁ",
	["Ⱂ"] = "ⱂ",
	["Ⱃ"] = "ⱃ",
	["Ⱄ"] = "ⱄ",
	["Ⱅ"] = "ⱅ",
	["Ⱆ"] = "ⱆ",
	["Ⱇ"] = "ⱇ",
	["Ⱈ"] = "ⱈ",
	["Ⱉ"] = "ⱉ",
	["Ⱊ"] = "ⱊ",
	["Ⱋ"] = "ⱋ",
	["Ⱌ"] = "ⱌ",
	["Ⱍ"] = "ⱍ",
	["Ⱎ"] = "ⱎ",
	["Ⱏ"] = "ⱏ",
	["Ⱐ"] = "ⱐ",
	["Ⱑ"] = "ⱑ",
	["Ⱒ"] = "ⱒ",
	["Ⱓ"] = "ⱓ",
	["Ⱔ"] = "ⱔ",
	["Ⱕ"] = "ⱕ",
	["Ⱖ"] = "ⱖ",
	["Ⱗ"] = "ⱗ",
	["Ⱘ"] = "ⱘ",
	["Ⱙ"] = "ⱙ",
	["Ⱚ"] = "ⱚ",
	["Ⱛ"] = "ⱛ",
	["Ⱜ"] = "ⱜ",
	["Ⱝ"] = "ⱝ",
	["Ⱞ"] = "ⱞ",
	["Ⱡ"] = "ⱡ",
	["Ɫ"] = "ɫ",
	["Ᵽ"] = "ᵽ",
	["Ɽ"] = "ɽ",
	["Ⱨ"] = "ⱨ",
	["Ⱪ"] = "ⱪ",
	["Ⱬ"] = "ⱬ",
	["Ⱶ"] = "ⱶ",
	["Ⲁ"] = "ⲁ",
	["Ⲃ"] = "ⲃ",
	["Ⲅ"] = "ⲅ",
	["Ⲇ"] = "ⲇ",
	["Ⲉ"] = "ⲉ",
	["Ⲋ"] = "ⲋ",
	["Ⲍ"] = "ⲍ",
	["Ⲏ"] = "ⲏ",
	["Ⲑ"] = "ⲑ",
	["Ⲓ"] = "ⲓ",
	["Ⲕ"] = "ⲕ",
	["Ⲗ"] = "ⲗ",
	["Ⲙ"] = "ⲙ",
	["Ⲛ"] = "ⲛ",
	["Ⲝ"] = "ⲝ",
	["Ⲟ"] = "ⲟ",
	["Ⲡ"] = "ⲡ",
	["Ⲣ"] = "ⲣ",
	["Ⲥ"] = "ⲥ",
	["Ⲧ"] = "ⲧ",
	["Ⲩ"] = "ⲩ",
	["Ⲫ"] = "ⲫ",
	["Ⲭ"] = "ⲭ",
	["Ⲯ"] = "ⲯ",
	["Ⲱ"] = "ⲱ",
	["Ⲳ"] = "ⲳ",
	["Ⲵ"] = "ⲵ",
	["Ⲷ"] = "ⲷ",
	["Ⲹ"] = "ⲹ",
	["Ⲻ"] = "ⲻ",
	["Ⲽ"] = "ⲽ",
	["Ⲿ"] = "ⲿ",
	["Ⳁ"] = "ⳁ",
	["Ⳃ"] = "ⳃ",
	["Ⳅ"] = "ⳅ",
	["Ⳇ"] = "ⳇ",
	["Ⳉ"] = "ⳉ",
	["Ⳋ"] = "ⳋ",
	["Ⳍ"] = "ⳍ",
	["Ⳏ"] = "ⳏ",
	["Ⳑ"] = "ⳑ",
	["Ⳓ"] = "ⳓ",
	["Ⳕ"] = "ⳕ",
	["Ⳗ"] = "ⳗ",
	["Ⳙ"] = "ⳙ",
	["Ⳛ"] = "ⳛ",
	["Ⳝ"] = "ⳝ",
	["Ⳟ"] = "ⳟ",
	["Ⳡ"] = "ⳡ",
	["Ⳣ"] = "ⳣ",
	["Ａ"] = "ａ",
	["Ｂ"] = "ｂ",
	["Ｃ"] = "ｃ",
	["Ｄ"] = "ｄ",
	["Ｅ"] = "ｅ",
	["Ｆ"] = "ｆ",
	["Ｇ"] = "ｇ",
	["Ｈ"] = "ｈ",
	["Ｉ"] = "ｉ",
	["Ｊ"] = "ｊ",
	["Ｋ"] = "ｋ",
	["Ｌ"] = "ｌ",
	["Ｍ"] = "ｍ",
	["Ｎ"] = "ｎ",
	["Ｏ"] = "ｏ",
	["Ｐ"] = "ｐ",
	["Ｑ"] = "ｑ",
	["Ｒ"] = "ｒ",
	["Ｓ"] = "ｓ",
	["Ｔ"] = "ｔ",
	["Ｕ"] = "ｕ",
	["Ｖ"] = "ｖ",
	["Ｗ"] = "ｗ",
	["Ｘ"] = "ｘ",
	["Ｙ"] = "ｙ",
	["Ｚ"] = "ｚ",
	["𐐀"] = "𐐨",
	["𐐁"] = "𐐩",
	["𐐂"] = "𐐪",
	["𐐃"] = "𐐫",
	["𐐄"] = "𐐬",
	["𐐅"] = "𐐭",
	["𐐆"] = "𐐮",
	["𐐇"] = "𐐯",
	["𐐈"] = "𐐰",
	["𐐉"] = "𐐱",
	["𐐊"] = "𐐲",
	["𐐋"] = "𐐳",
	["𐐌"] = "𐐴",
	["𐐍"] = "𐐵",
	["𐐎"] = "𐐶",
	["𐐏"] = "𐐷",
	["𐐐"] = "𐐸",
	["𐐑"] = "𐐹",
	["𐐒"] = "𐐺",
	["𐐓"] = "𐐻",
	["𐐔"] = "𐐼",
	["𐐕"] = "𐐽",
	["𐐖"] = "𐐾",
	["𐐗"] = "𐐿",
	["𐐘"] = "𐑀",
	["𐐙"] = "𐑁",
	["𐐚"] = "𐑂",
	["𐐛"] = "𐑃",
	["𐐜"] = "𐑄",
	["𐐝"] = "𐑅",
	["𐐞"] = "𐑆",
	["𐐟"] = "𐑇",
	["𐐠"] = "𐑈",
	["𐐡"] = "𐑉",
	["𐐢"] = "𐑊",
	["𐐣"] = "𐑋",
	["𐐤"] = "𐑌",
	["𐐥"] = "𐑍",
	["𐐦"] = "𐑎",
	["𐐧"] = "𐑏",
}

-- returns the number of bytes used by the UTF-8 character at byte i in s
-- also doubles as a UTF-8 character validator
function utf8.clen (s, i)
	-- argument defaults
	i = i or 1

	local c = s:byte(i)

	-- determine bytes needed for character, based on RFC 3629
	-- validate byte 1
	if c > 0 and c <= 127 then
		-- UTF8-1
		return 1

	elseif c >= 194 and c <= 223 then
		-- UTF8-2
		local c2 = s:byte(i + 1)

		if not c2 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end

		return 2

	elseif c >= 224 and c <= 239 then
		-- UTF8-3
		local c2 = s:byte(i + 1)
		local c3 = s:byte(i + 2)

		if not c2 or not c3 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c == 224 and (c2 < 160 or c2 > 191) then
			error("Invalid UTF-8 character")
		elseif c == 237 and (c2 < 128 or c2 > 159) then
			error("Invalid UTF-8 character")
		elseif c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end

		-- validate byte 3
		if c3 < 128 or c3 > 191 then
			error("Invalid UTF-8 character")
		end

		return 3

	elseif c >= 240 and c <= 244 then
		-- UTF8-4
		local c2 = s:byte(i + 1)
		local c3 = s:byte(i + 2)
		local c4 = s:byte(i + 3)

		if not c2 or not c3 or not c4 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c == 240 and (c2 < 144 or c2 > 191) then
			error("Invalid UTF-8 character")
		elseif c == 244 and (c2 < 128 or c2 > 143) then
			error("Invalid UTF-8 character")
		elseif c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end

		-- validate byte 3
		if c3 < 128 or c3 > 191 then
			error("Invalid UTF-8 character")
		end

		-- validate byte 4
		if c4 < 128 or c4 > 191 then
			error("Invalid UTF-8 character")
		end

		return 4

	else
		error("Invalid UTF-8 character")
	end
end

-- functions identically to string.sub except that i and j are UTF-8 characters
-- instead of bytes
function utf8.sub (s, i, j)
	-- argument defaults
	j = j or -1

	local pos = 1
	local bytes = s:len()
	local len = 0

	-- only set l if i or j is negative
	local l = (i >= 0 and j >= 0) or utf8.len(s)
	local startChar = (i >= 0) and i or l + i + 1
	local endChar	 = (j >= 0) and j or l + j + 1

	-- can't have start before end!
	if startChar > endChar then
		return ""
	end

	-- byte offsets to pass to string.sub
	local startByte,endByte = 1,bytes

	while pos <= bytes do
		len = len + 1

		if len == startChar then
			startByte = pos
		end

		pos = pos + utf8.clen(s, pos)

		if len == endChar then
			endByte = pos - 1
			break
		end
	end

	if startChar > len then startByte = bytes+1	 end
	if endChar	 < 1	 then endByte	 = 0		 end

	return s:sub(startByte, endByte)
end

-- replace UTF-8 characters based on a mapping table
function utf8.replace (s, mapping)
	-- argument checking

	local pos = 1
	local bytes = s:len()
	local clen
	local newstr = ""

	while pos <= bytes do
		clen = utf8.clen(s, pos)
		local c = s:sub(pos, pos + clen - 1)

		newstr = newstr .. (mapping[c] or c)

		pos = pos + clen
	end

	return newstr
end

-- identical to string.upper except it knows about unicode simple case conversions
function utf8.upper (s)
	return utf8.replace(s, utf8_lc_uc)
end

-- identical to string.lower except it knows about unicode simple case conversions
function utf8.lower (s)
	return utf8.replace(s, utf8_uc_lc)
end

-- identical to string.reverse except that it supports UTF-8
function utf8.reverse (s)
	-- argument checking

	local bytes = s:len()
	local pos = bytes
	local clen
	local newstr = ""

	while pos > 0 do
		c = s:byte(pos)
		while c >= 128 and c <= 191 do
			pos = pos - 1
			c = s:byte(pos)
		end

		clen = utf8.clen(s, pos)

		newstr = newstr .. s:sub(pos, pos + clen - 1)

		pos = pos - 1
	end

	return newstr
end

-- http://en.wikipedia.org/wiki/Utf8
-- http://developer.coronalabs.com/code/utf-8-conversion-utility
function utf8.uchar(unicode)
	if unicode <= 0x7F then return string.char(unicode) end

	if (unicode <= 0x7FF) then
		local Byte0 = 0xC0 + math.floor(unicode / 0x40)
		local Byte1 = 0x80 + (unicode % 0x40)
		return string.char(Byte0, Byte1)
	end

	if (unicode <= 0xFFFF) then
		local Byte0 = 0xE0 +	math.floor(unicode / 0x1000)
		local Byte1 = 0x80 + (math.floor(unicode / 0x40) % 0x40)
		local Byte2 = 0x80 + (unicode % 0x40)
		return string.char(Byte0, Byte1, Byte2)
	end

	if (unicode <= 0x10FFFF) then
		local code = unicode
		local Byte3= 0x80 + (code % 0x40)
		code		 = math.floor(code / 0x40)
		local Byte2= 0x80 + (code % 0x40)
		code		 = math.floor(code / 0x40)
		local Byte1= 0x80 + (code % 0x40)
		code		 = math.floor(code / 0x40)
		local Byte0= 0xF0 + code

		return string.char(Byte0, Byte1, Byte2, Byte3)
	end

	error('Unicode cannot be greater than U+10FFFF!')
end

local shift_6	= 2^6
local shift_12 = 2^12
local shift_18 = 2^18

function utf8.unicode (str, i, j, byte_pos)
	i = i or 1
	j = j or i

	if i > j then return end

	local char,bytes

	if byte_pos then
		bytes = utf8.clen(str,byte_pos)
		char	= str:sub(byte_pos,byte_pos-1+bytes)
	else
		char,byte_pos = utf8.sub(str,i,i)
		bytes		 = #char
	end

	local unicode

	if bytes == 1 then unicode = string.byte(char) end
	if bytes == 2 then
		local byte0,byte1 = string.byte(char,1,2)
		local code0,code1 = byte0-0xC0,byte1-0x80
		unicode = code0*shift_6 + code1
	end
	if bytes == 3 then
		local byte0,byte1,byte2 = string.byte(char,1,3)
		local code0,code1,code2 = byte0-0xE0,byte1-0x80,byte2-0x80
		unicode = code0*shift_12 + code1*shift_6 + code2
	end
	if bytes == 4 then
		local byte0,byte1,byte2,byte3 = string.byte(char,1,4)
		local code0,code1,code2,code3 = byte0-0xF0,byte1-0x80,byte2-0x80,byte3-0x80
		unicode = code0*shift_18 + code1*shift_12 + code2*shift_6 + code3
	end

	return unicode,utf8.unicode(str, i+1, j, byte_pos+bytes)
end

-- Returns an iterator which returns the next substring and its byte interval
function utf8.gensub(str, sub_len)
	sub_len		= sub_len or 1
	local byte_pos = 1
	local len		= #str
	return function()
		local char_count = 0
		local start		= byte_pos
		repeat
			if byte_pos > len then return end
			char_count	= char_count + 1
			local bytes = utf8.clen(str,byte_pos)
			byte_pos	= byte_pos+bytes

		until char_count == sub_len

		local last	= byte_pos-1
		local sub	 = str:sub(start,last)
		return sub, start, last
	end
end

string.utf8len		 = utf8.len
string.utf8sub		 = utf8.sub
string.utf8reverse	 = utf8.reverse
string.utf8char		= utf8.char
string.utf8unicode	 = utf8.unicode
string.utf8gensub	= utf8.gensub
string.utf8upper	= utf8.upper
string.utf8lower	 = utf8.lower

-- TODO? save configs

local chat_x = CreateClientConVar("lounge_chat_x", 2 / 1080, true, false)
local chat_y = CreateClientConVar("lounge_chat_y", 0.52, true, false)
local chat_w = CreateClientConVar("lounge_chat_w", 550 / 1920, true, false)
local chat_h = CreateClientConVar("lounge_chat_h", 280 / 1080, true, false)
local chat_message_hidetime = CreateClientConVar("lounge_chat_hidetime", 15, true, false)
local chat_timestamps = CreateClientConVar("lounge_chat_timestamps", 0, true, false)
local chat_hide_options = CreateClientConVar("lounge_chat_hide_options", 0, true, false)
local chat_no_scroll_while_open = CreateClientConVar("lounge_chat_no_openscroll", 0, true, false)
local render_character_avatar = CreateClientConVar("br_render_avatar", 1, true, false, "", 0, 1)

--
cvars.AddChangeCallback("lounge_chat_x", function(cvar, old, new)
    if (IsValid(_LOUNGE_CHAT)) then
        local x = ScrW() * math.Clamp(tonumber(new) or chat_x:GetDefault(), 0, (ScrW() - _LOUNGE_CHAT:GetWide()) / ScrW())
        _LOUNGE_CHAT.x = x
    end
end)

cvars.AddChangeCallback("lounge_chat_y", function(cvar, old, new)
    if (IsValid(_LOUNGE_CHAT)) then
        local y = ScrH() * math.Clamp(tonumber(new) or chat_y:GetDefault(), 0, (ScrH() - _LOUNGE_CHAT:GetTall()) / ScrH())
        _LOUNGE_CHAT.y = y
    end
end)

cvars.AddChangeCallback("lounge_chat_w", function(cvar, old, new)
    if (IsValid(_LOUNGE_CHAT)) then
        local w = ScrW() * math.Clamp(tonumber(new) or chat_w:GetDefault(), 0, 1)
        _LOUNGE_CHAT:SetWide(w)
        _LOUNGE_CHAT.m_Close:AlignRight(0)
        _LOUNGE_CHAT.m_Options:MoveLeftOf(_LOUNGE_CHAT.m_Close)
    end
end)

cvars.AddChangeCallback("lounge_chat_h", function(cvar, old, new)
    if (IsValid(_LOUNGE_CHAT)) then
        local h = ScrH() * math.Clamp(tonumber(new) or chat_h:GetDefault(), 0, 1)
        _LOUNGE_CHAT:SetTall(h)
    end
end)

local chat_message_hidetime_cache = chat_message_hidetime:GetFloat()

cvars.AddChangeCallback("lounge_chat_hidetime", function(cvar, old, new)
    chat_message_hidetime_cache = tonumber(new) or 15
end)

--
local matClose = Material("shenesis/chat/close.png", "noclamp smooth")
local matSmile = Material("shenesis/chat/smile.png", "noclamp smooth")
local matOptions = Material("shenesis/chat/options.png", "noclamp smooth")

LOUNGE_CHAT.ChatboxOpen = false
LOUNGE_CHAT.History = {}

local function IsPlayer(e)
    return type(e) == "Player" and IsValid(e)
end

local function RemoveIfValid(e)
    if (IsValid(e)) then
        e:Remove()
    end
end

local function FindPlayer(cont)
    for _, v in pairs (cont) do
        if (IsPlayer(v)) then
            return v
        end
    end

    return NULL
end

local nopaint = function() end

LOUNGE_CHAT.FontsToGlow = {}
LOUNGE_CHAT.FontsToBold = {}

function LOUNGE_CHAT:CreateChatboxFonts()
    local fntname = self.FontName
    local fntnamebold = self.FontNameBold
    local weight = 500
    local boldweight = 1000
    local sizes = {8, 10, 12, 14, 16, 18, 20, 24}

    for _, v in ipairs (sizes) do
        local n = "LOUNGE_CHAT_" .. v

        surface.CreateFont(n, {font = fntname, size = v, weight = weight})
        surface.CreateFont(n .. "_B", {font = fntnamebold, size = v, weight = boldweight})
        surface.CreateFont(n .. "_G", {font = fntnamebold, size = v, blursize = self.BlurSize, additive = true})

        self.FontsToGlow[n] = n .. "_G"
        self.FontsToBold[n] = n .. "_B"
    end
end

function LOUNGE_CHAT:CreateChatbox()
    RemoveIfValid(_LOUNGE_CHAT)
    RemoveIfValid(_LOUNGE_CHAT_EMOTICONS)

    local W, H = ScrW(), ScrH()
    local scale = math.Clamp(H / 1080, 0.7, 1)
    _LOUNGE_CHAT_SCALE = scale

    local wi, he = W * math.Clamp(chat_w:GetFloat(), 0, 1), H * math.Clamp(chat_h:GetFloat(), 0, 1)
    wi = math.max(wi, 400 * scale)
    he = math.max(he, 200 * scale)

    local x, y = W * math.Clamp(chat_x:GetFloat(), 0, (W - wi) / W), H * math.Clamp(chat_y:GetFloat(), 0, (H - he) / H)

    local frame = vgui.Create("DFrame")
    frame:SetTitle("")
    frame:ShowCloseButton(false)
    frame:SetSizable(true)
    frame:SetScreenLock(true)
    frame:SetMinWidth(wi * 0.5)
    frame:SetMinHeight(he * 0.5)
    frame:SetSize(wi, he)
    frame:SetPos(x, y)
    frame:DockPadding(4, 27, 4, 4)
    frame.m_fAlpha = 0
    frame.Paint = function(me, w, h)
        if (gui.IsGameUIVisible()) then
            return end

        if (self.ChatboxOpen or me.m_fAlpha > 0) then
            local ch, cb = self.Color("header"), self.Color("bg")
            local a = me.m_fAlpha or 255
            local af = me.m_fAlphaFrac or 1

            draw.RoundedBoxEx(4, 0, 0, w, 22, Color(ch.r, ch.g, ch.b, ch.a * af), true, true, false, false)
            draw.RoundedBoxEx(4, 0, 22, w, h - 22, Color(cb.r, cb.g, cb.b, cb.a * af), false, false, true, true)

            me.m_Title:SetAlpha(a)
            me.m_Close:SetAlpha(a)
            me.m_Entry:SetAlpha(a)
            me.m_Send:SetAlpha(a)
            me.m_Title:PaintManual()
            me.m_Close:PaintManual()
            me.m_Entry:PaintManual()
            me.m_Send:PaintManual()
        end

        me.m_History:PaintManual()
    end
    frame.OldThink = frame.Think
    frame.Think = function(me)
        if (!self.ChatboxOpen) then
            return end

        local ox, oy = me.x, me.y
        local ow, oh = me:GetSize()

        me:OldThink()

        if (me.Dragging) then
            if (ox ~= me.x) then
                RunConsoleCommand("lounge_chat_x", tostring(ox / W))
            end
            if (oy ~= me.y) then
                RunConsoleCommand("lounge_chat_y", tostring(oy / H))
            end
        end

        if (me.Sizing) then
            if (ow ~= me:GetWide()) then
                RunConsoleCommand("lounge_chat_w", tostring(ow / W))
            end
            if (oh ~= me:GetTall()) then
                RunConsoleCommand("lounge_chat_h", tostring(oh / H))
            end
        end
    end
    frame.OldOnMouseReleased = frame.OnMouseReleased
    frame.OnMouseReleased = function(me, mc)
        me:OldOnMouseReleased(mc)

        if (mc == MOUSE_RIGHT) then
            me:ShowMenu()
        end
    end
    frame.ShowMenu = function(me)
        local menu = self.Menu()

            menu:AddOption(self.Lang("clear_chat"), function()
                RunConsoleCommand("lounge_chat_clear")
            end)

            menu:AddOption(self.Lang("chat_parsers"), function()
                self:ShowParsers()
            end)

            menu:AddOption(self.Lang("chat_options"), function()
                self:ShowOptions()
            end)

            menu:AddOption(self.Lang("reset_position"), function()
                RunConsoleCommand("lounge_chat_x", chat_x:GetDefault())
                RunConsoleCommand("lounge_chat_y", chat_y:GetDefault())
            end)

            menu:AddOption(self.Lang("reset_size"), function()
                RunConsoleCommand("lounge_chat_w", chat_w:GetDefault())
                RunConsoleCommand("lounge_chat_h", chat_h:GetDefault())
            end)

        menu:Open()
    end
    _LOUNGE_CHAT = frame

        local title = self.Label("", "LOUNGE_CHAT_16", self.Color("text"), frame)
        title:SetPaintedManually(true)
        title:AlignTop(11 - title:GetTall() * 0.5)
        title.x = title.y * 2
        title.Think = function(me)
            if (!self.ChatboxOpen) then
                return end

            if (!me.m_fNextRefresh or CurTime() >= me.m_fNextRefresh) then
                me.m_fNextRefresh = CurTime() + 1

                local t = self.ChatTitle
                t = t:Replace("%hostname%", GetHostName())
                t = t:Replace("%players%", self.Lang("players_online") .. ": " .. #player.GetAll() .. "/" .. game.MaxPlayers())
                t = t:Replace("%uptime%", self.Lang("server_uptime") .. ": " .. self.SecondsToEnglish(CurTime()))

                me:SetText(t)
                me:SizeToContentsX()
            end
        end
        frame.m_Title = title

        local close = vgui.Create("DButton", frame)
        close:SetPaintedManually(true)
        close:SetText("")
        close:SetSize(22, 22)
        close:AlignRight(0)
        close.Paint = function(me, w, h)
            if (me.Hovered) then
                draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("close_hover"), false, true, false, false)
            end

            if (me:IsDown()) then
                draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("hover"), false, true, false, false)
            end

            surface.SetDrawColor(me:IsDown() and self.Color("text_down") or self.Color("text"))
            surface.SetMaterial(matClose)
            surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 12 * scale, 12 * scale, 0)

            local b = chat_hide_options:GetBool()
            if (!b) then
                frame.m_Options:PaintManual()
            end
            frame.m_Options:SetMouseInputEnabled(!b)
        end
        close.DoClick = function(me)
            self:CloseChatbox()
        end
        frame.m_Close = close

        local options = vgui.Create("DButton", frame)
        options:SetPaintedManually(true)
        options:SetText("")
        options:SetSize(22, 22)
        options:MoveLeftOf(close)
        options.Paint = function(me, w, h)
            local c = self.Color("text")

            surface.SetDrawColor(c.r, c.g, c.b, c.a * (me.Hovered and 1 or 0.5))
            surface.SetMaterial(matOptions)
            surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 12 * scale, 12 * scale, 0)
        end
        options.DoClick = function(me)
            frame:ShowMenu()
        end
        frame.m_Options = options

        local history = vgui.Create("DScrollPanel", frame)
        self.PaintScroll(history)
        history:SetPaintedManually(true)
        history:Dock(FILL)
        history:DockMargin(0, 0, 0, 4)
        history.PerformLayout = function(me)
            local h = me.pnlCanvas:GetTall()
            local w = me:GetWide()
            local y = 0

            me:Rebuild()

            me.VBar:SetUp(me:GetTall(), me.pnlCanvas:GetTall())
            y = me.VBar:GetOffset()

            if (me.VBar.Enabled) then w = w - me.VBar:GetWide() end

            me.pnlCanvas:SetWide(w)

            me:Rebuild()
            if (h > me:GetTall()) then
                me.pnlCanvas:AlignTop(y)
            else
                me.pnlCanvas:AlignBottom(0)
            end

            if (h ~= me.pnlCanvas:GetTall()) then
                me.VBar:SetScroll(me.VBar:GetScroll()) -- Make sure we are not too far down!
            end
        end
        history.Rebuild = function(me)
            -- Rewrite this shit to take invisible els into account
            local cv = me:GetCanvas()
            local chi = cv:GetChildren()
            local h = 4

            for _, v in ipairs (chi) do
                h = h + v:GetTall()
            end

            cv:SetTall(h + (#chi > 0 and 4 or 0))
        end
        history.ScrollToBottom = function(me)
            me:PerformLayout()

            local vbar = me.VBar

            local anim = vbar:NewAnimation(self.Anims.FadeInTime)
            anim.StartPos = vbar.Scroll
            anim.TargetPos = vbar.CanvasSize
            anim.Think = function(anim, pnl, fraction)
                pnl:SetScroll(Lerp(fraction, anim.StartPos, anim.TargetPos))
            end
        end
        history.Think = function(me)
            local sc = me.VBar:GetScroll()
            frame.m_iScrollMin = sc
            frame.m_iScrollMax = sc + frame:GetTall()
        end
        local aaaaa = Material("vgui/gradient-l")
        history.Paint = function(me, w, h)
            if (self.ChatboxOpen) then
                local ci = self.Color("inbg")
                local a = frame.m_fAlpha or 255
                local af = frame.m_fAlphaFrac or 1

                draw.RoundedBox(4, 0, 0, w, h, Color(ci.r, ci.g, ci.b, ci.a * af))

                me.VBar:SetAlpha(a)
            else
                me.VBar:SetAlpha(0)
            end
        end
        frame.m_History = history

            history:InvalidateParent(true)
            history.pnlCanvas:DockPadding(4, 4, 4, 4)

        local bottom = vgui.Create("DPanel", frame)
        bottom:SetDrawBackground(false)
        bottom:Dock(BOTTOM)
        frame.m_Bottom = bottom

            local entry = vgui.Create("DTextEntry", bottom)
            entry:SetFont(self.ChatboxFont)
            entry:SetTextColor(self.Color("text"))
            entry:SetHighlightColor(self.Color("header"))
            entry:SetDrawLanguageID(false)
            entry:SetPaintedManually(true)
            entry:SetUpdateOnType(true)
            entry:Dock(FILL)
            entry.OldOnKeyCodeTyped = entry.OnKeyCodeTyped
            local aaaaa = Material("vgui/gradient-l")
            entry.Paint = function(me, w, h)
                draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("inbg"), true, false, true, false)

                me:DrawTextEntryText(me:GetTextColor(), me:GetHighlightColor(), me:GetTextColor())

                if (vgui.GetKeyboardFocus() == frame) then
                    me:RequestFocus()
                end
            end
            entry.OnKeyCodeTyped = function(me, kc)
                if (kc == KEY_ESCAPE) then
                    self:CloseChatbox()
                elseif (kc == KEY_TAB) then
                    local str = hook.Call("OnChatTab", GAMEMODE, me:GetValue())
                    if (str) then
                        me:SetText(str)
                    end
                elseif (kc == KEY_UP) then
                    if (#self.History > 0) then
                        if (!me.m_iCurPos) then
                            me.m_iCurPos = #self.History
                            me:SetText(self.History[me.m_iCurPos])
                            me:SetCaretPos(me:GetText():len())
                        elseif (me.m_iCurPos > 1) then
                            me.m_iCurPos = me.m_iCurPos - 1
                            me:SetText(self.History[me.m_iCurPos])
                            me:SetCaretPos(me:GetText():len())
                        end
                    end
                elseif (kc == KEY_DOWN) then
                    if (me.m_iCurPos and me.m_iCurPos < #self.History) then
                        me.m_iCurPos = me.m_iCurPos + 1
                        me:SetText(self.History[me.m_iCurPos])
                        me:SetCaretPos(me:GetText():len())
                    end
                end

                me:OldOnKeyCodeTyped(kc)
            end
            entry.AllowInput = function(me, str)
                if (me:GetText():len() >= 126) then
                    surface.PlaySound("resource/warning.wav")
                    return true
                end
            end
            entry.OnValueChange = function(me, val)
                if (val:len() >= 126) then
                    val = val:sub(1, 126)
                    me:SetText(val)
                    me:SetCaretPos(val:len())
                end
                hook.Call("ChatTextChanged", GAMEMODE, val)
            end
            entry.OnEnter = function(me)
                local val = me:GetValue()
                if (val:Trim() ~= "") then
                    local max = 126
                    val = self.sub(val, 1, max)

                    if (val:find('"') and !val:find(";")) then
                        LocalPlayer():ConCommand((frame.m_bTeam and "say_team" or "say") .. " \"" .. val .. "\"")
                    else
                        if LocalPlayer():GTeam() != TEAM_SPEC then
                            local str1 = utf8.sub(val, 0, 1)
                            local str2 = utf8.sub(val, 2) || ""
                            val = utf8.upper(str1)..str2
                            --print(val, str1, str2)
                    		--local last = utf8.sub(val, -1)
                            --if (last != "." and last != "?" and last != "!" and last != "-" and last != "\"") then
                                --val = val .. "."
                            --end
                        end
                        RunConsoleCommand(frame.m_bTeam and "say_team" or "say" , val)
                    end
                    table.insert(self.History, val)
                end

                self:CloseChatbox()
            end
            frame.m_Entry = entry

            local send = LOUNGE_CHAT.Button("send", bottom, function()
                entry:OnEnter()
            end)
            send:SetPaintedManually(true)
            send:Dock(RIGHT)
            send:DockMargin(4, 0, 0, 0)
            send.OldPaint = send.Paint
            send.Paint = function(me, w, h)
                me:OldPaint(w, h)
                frame.m_Emoticons:PaintManual()
            end
            frame.m_Send = send

            local emoticons = LOUNGE_CHAT.Button("", bottom, function()
                entry:OnEnter()
            end)
            emoticons:SetPaintedManually(true)
            emoticons:SetWide(bottom:GetTall())
            emoticons:Dock(RIGHT)
            emoticons.m_bHovering = false
            emoticons.m_fAlphaFrac = 40 / 255
            emoticons.m_fAlpha = 40
            emoticons.Paint = function(me, w, h)
                draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("inbg"), false, true, false, true)



                local b = me.Hovered or (IsValid(_LOUNGE_CHAT_EMOTICONS) and _LOUNGE_CHAT_EMOTICONS:IsVisible())
                if (b ~= me.m_bHovering) then
                    me.m_bHovering = b

                    me:Stop()
                    local anim = me:NewAnimation(self.Anims.FadeInTime)
                    anim.m_fStart = me.m_fAlpha
                    anim.m_fTarget = b and 200 or 40
                    anim.Think = function(anim, _, fraction)
                        me.m_fAlphaFrac = fraction
                        me.m_fAlpha = Lerp(fraction, anim.m_fStart, anim.m_fTarget)
                    end
                end

                local c = self.Color("text")
                surface.SetDrawColor(c.r, c.g, c.b, me.m_fAlpha)
                surface.SetMaterial(matSmile)
                surface.DrawTexturedRectRotated(h * 0.5, h * 0.5, 14, 14, 0)
            end
            emoticons.DoClick = function()
                self:ShowEmoticons()
            end
            frame.m_Emoticons = emoticons

    self:ShowEmoticons()
end

function LOUNGE_CHAT:ShowParsers()
    if (IsValid(_LOUNGE_CHAT_PARSERS)) then
        _LOUNGE_CHAT_PARSERS:Remove()
    end

    local scale = math.Clamp(ScrH() / 1080, 0.7, 1)
    local wi, he = 500 * scale, 600 * scale

    local frame = vgui.Create("EditablePanel")
    frame:SetSize(wi, he)
    frame:Center()
    frame:MakePopup()
    frame.m_bF4Down = true
    frame.Think = function(me)
        if (input.IsKeyDown(KEY_ESCAPE)) then
            me:Close()

            gui.HideGameUI()
            timer.Simple(0, gui.HideGameUI)
        end
    end
    frame.Paint = function(me, w, h)
        draw.RoundedBox(4, 0, 0, w, h, self.Color("bg"))
    end
    frame.Close = function(me)
        if (me.m_bClosing) then
            return end

        me.m_bClosing = true
        me:AlphaTo(0, self.Anims.FadeOutTime, 0, function()
            me:Remove()
        end)
    end
    _LOUNGE_CHAT_PARSERS = frame

        local th = 48 * scale
        local m = th * 0.25
        local m5 = m * 0.5

        local header = vgui.Create("DPanel", frame)
        header:SetTall(th)
        header:Dock(TOP)
        header.Paint = function(me, w, h)
            draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("header"), true, true, false, false)
        end

            local title = self.Lang("chat_parsers")

            local titlelbl = self.Label(title, "LOUNGE_CHAT_24", self.Color("text"), header)
            titlelbl:Dock(LEFT)
            titlelbl:DockMargin(m, 0, 0, 0)

            local close = vgui.Create("DButton", header)
            close:SetText("")
            close:SetWide(th)
            close:Dock(RIGHT)
            close.Paint = function(me, w, h)
                if (me.Hovered) then
                    draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("close_hover"), false, true, false, false)
                end

                if (me:IsDown()) then
                    draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("hover"), false, true, false, false)
                end

                surface.SetDrawColor(me:IsDown() and self.Color("text_down") or self.Color("text"))
                surface.SetMaterial(matClose)
                surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 16 * scale, 16 * scale, 0)
            end
            close.DoClick = function(me)
                frame:Close()
            end

        local body = vgui.Create("DScrollPanel", frame)
        self.PaintScroll(body)
        body:SetDrawBackground(false)
        body:DockMargin(m, m, m, m)
        body:GetCanvas():DockPadding(m5, m5, m5, m5)
        body:Dock(FILL)
        body.Paint = function(me, w, h)
            draw.RoundedBox(4, 0, 0, w, h, self.Color("inbg"))
        end

            for i, ex in ipairs (self.MarkupsExamples) do
                if (ex.perm) then
                    local rest = self.MarkupsPermissions[ex.perm]
                    if (rest) then
                        local okay = false

                        if LocalPlayer():GTeam() != TEAM_SPEC then
                            okay = false
                        elseif (rest.usergroups and table.HasValue(rest.usergroups, LocalPlayer():GetUserGroup())) then
                            okay = true
                        elseif (rest.steamids) and (table.HasValue(rest.steamids, LocalPlayer():SteamID()) or table.HasValue(rest.steamids, LocalPlayer():SteamID64())) then
                            okay = true
                        end

                        if (!okay) then
                            continue end
                    end
                end

                local pnl = vgui.Create("DButton", body)
                pnl:SetText("")
                pnl:SetSize(wi - m * 2 - m5 * 2, 80 * scale)
                pnl:Dock(TOP)
                pnl:DockPadding(m5, m5, m5, m5)
                pnl.Paint = function(me, w, h)
                    draw.RoundedBox(4, 0, 0, w, h, self.Color("bg"))
                end
                pnl.DoClick = function()
                    local ch = _LOUNGE_CHAT
                    if (IsValid(ch) and IsValid(ch.m_Entry) and self.ChatboxOpen) then
                        local tx = ch.m_Entry:GetValue() .. ex.example
                        ch.m_Entry:SetText(tx)
                        ch.m_Entry:SetCaretPos(tx:len())

                        frame:Close()
                    end
                end

                    local lbl = self.Label(ex.tx, "LOUNGE_CHAT_16_B", self.Color("header"), pnl)
                    lbl:Dock(TOP)
                    lbl:DockMargin(0, 0, 0, m5)

                    local lbl = self.Label(self.Lang("usage") .. ": " .. ex.example, "LOUNGE_CHAT_16", self.Color("text"), pnl)
                    lbl:Dock(TOP)

                    local parsed = self:ParseLineWrap({ex.example}, pnl:GetWide() - m5 * 2, pnl, LocalPlayer())
                    parsed:Dock(TOP)
                    parsed:SetMouseInputEnabled(false)

                pnl:InvalidateLayout(true)
                pnl:SizeToChildren(false, true)

                if (i > 1) then
                    pnl:DockMargin(0, m5, 0, 0)
                end
            end

    frame:SetAlpha(0)
    frame:AlphaTo(255, self.Anims.FadeInTime)
end

concommand.Add("lounge_chat_parsers", function()
    LOUNGE_CHAT:ShowParsers()
end)

local function urlpaint(me, w, h)
    if (me.m_Image) then
        surface.SetDrawColor(color_white)
        surface.SetMaterial(me.m_Image)
        surface.DrawTexturedRect(0, 0, w, h)
    end
end

function LOUNGE_CHAT:ShowEmoticons()
    local frame = _LOUNGE_CHAT
    local lx, ly = frame.m_Emoticons:LocalToScreen(0, 0)
    local x, y = frame:ScreenToLocal(lx, ly)

    local old = _LOUNGE_CHAT_EMOTICONS
    if (IsValid(old)) then
        if (old:IsVisible()) then
            old:Close()
        else
            old:SetPos(frame:GetWide() - old:GetWide() - 8, y - old:GetTall() - 8)
            old:SetVisible(true)
            old:SetAlpha(0)
            old:AlphaTo(255, self.Anims.FadeInTime)
            old.m_bClosing = false
        end

        return
    end

    local pnl = vgui.Create("DPanel", frame)
    pnl:SetSize(frame:GetWide() * 0.4, frame:GetTall() * 0.4)
    pnl:SetPos(frame:GetWide() - pnl:GetWide() - 8, y - pnl:GetTall() - 8)
    pnl.Paint = function(me, w, h)
        draw.RoundedBox(4, 0, 0, w, h, self.Color("bg"))
    end
    pnl.Close = function(me)
        if (me.m_bClosing) then
            return end

        me.m_bClosing = true
        me:AlphaTo(0, self.Anims.FadeOutTime, 0, function()
            me:SetVisible()
        end)
    end
    _LOUNGE_CHAT_EMOTICONS = pnl

        local scroll = vgui.Create("DScrollPanel", pnl)
        self.PaintScroll(scroll)
        scroll:Dock(FILL)
        scroll:DockMargin(4, 4, 4, 4)

            local ilist = vgui.Create("DIconLayout", scroll)
            ilist:Dock(FILL)

            for id, em in SortedPairs (self.Emoticons) do
                if (em.restrict) then
                    local ok = false

                    local rest = em.restrict
                    if (rest.usergroups and table.HasValue(rest.usergroups, LocalPlayer():GetUserGroup())) then
                        ok = true
                    elseif (rest.steamids) and (table.HasValue(rest.steamids, LocalPlayer():SteamID()) or table.HasValue(rest.steamids, LocalPlayer():SteamID64())) then
                        ok = true
                    end

                    if (!ok) then
                        continue end
                end

                local img
                if (em.url) then
                    img = vgui.Create("DButton", ilist)
                    img:SetText("")
                    img.Paint = urlpaint

                    local mat = LOUNGE_CHAT.GetDownloadedImage(em.url)
                    if (mat) then
                        img.m_Image = mat
                    else
                        LOUNGE_CHAT.DownloadImage(
                            em.url,
                            function(mat)
                                if (IsValid(img)) then
                                    img.m_Image = mat
                                end
                            end
                        )
                    end
                else
                    img = vgui.Create("DImageButton", ilist)
                    img:SetImage(em.path)
                end

                img:SetToolTip(":" .. id .. ":")
                img:SetSize(em.w, em.h)
                img.DoClick = function()
                    if (IsValid(frame) and IsValid(frame.m_Entry)) then
                        local tx = frame.m_Entry:GetValue() .. ":" .. id .. ":"
                        frame.m_Entry:SetText(tx)
                        frame.m_Entry:SetCaretPos(tx:len())

                        pnl:Close()
                    end
                end
            end

    pnl:SetAlpha(0)
    pnl:AlphaTo(255, self.Anims.FadeInTime)

    return pnl
end

function LOUNGE_CHAT:SplitLine(tx, fnt, maxwi, cont, i)
    if (!IsValid(_LOUNGE_CHAT)) then
        return end

    local expl = string.Explode(" ", tx)
    local realmaxwi = _LOUNGE_CHAT.m_History:GetWide() - 24
    surface.SetFont(fnt)

    -- Check where to split line for 1 single word bigger than the remaining space
    -- (retards spamming "aaaaaaaaaaaa")
    for _, tx in pairs (expl) do
        local sw = surface.GetTextSize(tx)
        if (sw >= realmaxwi) then
            local s = ""

            if (self.UseUTF8) then
                tx = utf8.force(tx)

                for p, c in utf8.codes(tx) do
                    local n = s .. utf8.char(c)

                    local sw2 = surface.GetTextSize(n)
                    if (sw2 >= maxwi) then
                        s = self.sub(n, 1, -3)
                        table.insert(cont, i + 1, self.sub(tx, s:len() + 1))

                        cont[i] = s
                        return s
                    else
                        s = n
                    end
                end
            else
                for j = 1, #tx do
                    local n = s .. tx[j]

                    local sw2 = surface.GetTextSize(n)
                    if (sw2 >= maxwi) then
                        s = string.sub(n, 1, -3)
                        table.insert(cont, i + 1, tx:sub(s:len() + 1))

                        cont[i] = s
                        return s
                    else
                        s = n
                    end
                end
            end
        end
    end

    -- Check where to split line for spaced words
    local sw = surface.GetTextSize(" ")

    local line = {}
    local w = 0

    for id, wo in pairs (expl) do
        local _w, _h = surface.GetTextSize(wo)
        if (id == 1 or w + _w < maxwi) then
            w = w + _w + sw
            table.insert(line, wo)
        else
            table.insert(cont, i + 1, table.concat(expl, " ", id))
            break
        end
    end

    cont[i] = #line == 1 and line[1] .. " " or table.concat(line, " ")
    return cont[i]
end

function LOUNGE_CHAT:ParseMarkups(parent, sender, tx, defaultfont, defaultcolor, maxwi, cont, i, bypass, underline)
	if sender and sender.Name and sender:Name() == tx then return tx end
    local parsed = false
    for _, mup in ipairs (self.ChatMarkups) do
        local d = {string.find(tx, mup.match)}
        local s, e = d[1], d[2]
        if (s) then
            local okay = true

            if (mup.perm and IsValid(sender) and !bypass) then
                local rest = self.MarkupsPermissions[mup.perm]
                if (rest) then
                    okay = false

                    if sender:GTeam() != TEAM_SPEC then
                        okay = false
                    elseif (rest.usergroups and table.HasValue(rest.usergroups, sender:GetUserGroup())) then
                        okay = true
                    elseif (rest.steamids) and (table.HasValue(rest.steamids, sender:SteamID()) or table.HasValue(rest.steamids, sender:SteamID64())) then
                        okay = true
                    end
                end
            end

            if (okay) and (!IsValid(sender) or sender:GTeam() == TEAM_SPEC) then
                table.remove(d, 1)
                table.remove(d, 1)

                parsed = true
                cont[i] = ""

                local before = self.sub(tx, 1, s - 1)
                local after = self.sub(tx, e + 1)
                if (before ~= "") then
                    table.insert(cont, i + 1, before)
                    i = i + 1
                end

                local res = mup.func({parent = parent, sender = sender, args = d, text = self.sub(tx, s, e), defaultfont = defaultfont, defaultcolor = defaultcolor, underline = underline, maxwi = maxwi, cont = cont, i = i})
                if (res) then
                    if (istable(res) and !res.r) then
                        for __, v in pairs (res) do
                            table.insert(cont, i + 1, v)
                            i = i + 1
                        end
                    else
                        table.insert(cont, i + 1, res)
                        i = i + 1
                    end
                end

                if (after ~= "") then
                    table.insert(cont, i + 1, after)
                end
            end

            break
        end
    end

    if (parsed) then
        return nil
    else
        return tx
    end
end

local messagequeue = {}

function LOUNGE_CHAT:MakeChatLabel(tx, font, color, parent, underline)
    local ele = self.Label(tx, font, color, parent)
    ele:SetExpensiveShadow(1, color_black)
    ele:SetWide(ele:GetWide() + 1)

    if (underline) then
        ele.Paint = function(me, w, h)
            LOUNGE_CHAT.UnderlinePaint(me, w, h)
        end
    end

    return ele
end

function LOUNGE_CHAT.UnderlinePaint(me, w, h)
    surface.SetDrawColor(me:GetTextColor())
    surface.DrawRect(0, h - 2, w, 1)
    surface.SetDrawColor(0, 0, 0, 200)
    surface.DrawRect(1, h - 1, w - 2, 1)
end

function LOUNGE_CHAT:ParseLineWrap(cont, maxwi, parent, sender, noparse)
    if (maxwi == true) then
        if (IsValid(_LOUNGE_CHAT)) then
            maxwi = _LOUNGE_CHAT.m_History:GetWide() - 24
        else
            if (!IsValid(LocalPlayer())) then
                table.insert(messagequeue, {
                    cont = cont,
                    maxwi = maxwi,
                    parent = parent,
                    sender = sender,
                })

                return
            end

            maxwi = 100 -- que
        end
    end

    local origtext = ""

    local line = vgui.Create("DPanel", parent)
    line:SetDrawBackground(false)
    line.Paint = nopaint
    line.OnMousePressed = function(me, mc)
        if (mc == MOUSE_RIGHT) then
            me:ShowMenu()
        end
    end
    line.ShowMenu = function(me, add)
        local menu = self.Menu()

            menu:AddOption(self.Lang("copy_message"), function()
                SetClipboardText(origtext)
            end)

            if (add) then
                for _, v in pairs (add) do
                    menu:AddOption(self.Lang(v.text), function()
                        v.func()
                    end)
                end
            end

        menu:Open()
    end

        local contents = vgui.Create("DPanel", line)
        contents:Dock(FILL)
        contents:SetDrawBackground(false)
        contents.Paint = nopaint
        contents.OnMousePressed = function(me, mc)
            line:OnMousePressed(mc)
        end
        line.m_Contents = contents

    local bx = 0
    local x, y, w, lh = 0, 0, 0, 0
    local h = 0
    local nl = false
    local inline = {}

    local defaultfont = self.ChatboxFont
    local defaultcolor = color_white
    local noparse = noparse == true
    local bypassperm = false
    local underline = false
    local url, lua
    local urlbtns, luabtns = {}, {}

    local function urlpaint(me, w, h)
        local b = false
        for _, v in ipairs (me.m_Buttons) do
            if (IsValid(v) and v.Hovered) then
                b = true
                break
            end
        end

        me:SetTextColor(b and LOUNGE_CHAT.Color("url_hover") or LOUNGE_CHAT.Color("url"))

        LOUNGE_CHAT.UnderlinePaint(me, w, h)
    end

    local pre

    local tries = 0
    for i, el in pairs (cont) do
        tries = tries + 1
        if (tries > 512) then
            line:Remove()
            error("overflow!! (this shouldn't happen, report this to the author with the message)")
            return
        end

        local ele, forcebreak

        if (isstring(el) or isnumber(el)) then
            if (el == "") then
                continue end

                --if sender and sender.Name and sender:Name() == el then noparse = true else noparse = false end

            el = (noparse or url) and el or self:ParseMarkups(contents, sender, el, defaultfont, defaultcolor, maxwi - x, cont, i, bypassperm, underline)

            if (maxwi and el and el ~= "") then
                surface.SetFont(defaultfont)
                local _w, _h = surface.GetTextSize(el)
                if (_w > maxwi - x) then -- This string is gonna be too long, we need to split it!!
                    el = self:SplitLine(el, defaultfont, maxwi - x, cont, i)
                    if (el == "") then
                        nl = true
                    end
                end
            end

            if (el and el ~= "") then
                if (#inline == 0) then
                    el = el:TrimLeft()
                end

                ele = self:MakeChatLabel(el, defaultfont, defaultcolor, contents, underline)

                if (url and url ~= "") then
                    ele:SetMouseInputEnabled(true)
                    ele:SetWide(ele:GetWide() + 1)
                    ele:SetTall(ele:GetTall() + 2)
                    ele.Paint = urlpaint
                    ele.m_URL = url

                        local realurl = ele.m_URL:Trim()

                        local btn = vgui.Create("DButton", ele)
                        btn:SetToolTip(realurl)
                        btn:SetText("")
                        btn:Dock(FILL)
                        btn.Paint = function() end
                        btn.DoClick = function(me)
                            gui.OpenURL(realurl)
                        end
                        btn.DoRightClick = function(me)
                            line:ShowMenu({
                                {text = "copy_url", func = function()
                                    SetClipboardText(realurl)
                                end}
                            })
                        end
                        ele.m_Button = btn

                    table.insert(urlbtns, btn)
                    ele.m_Buttons = urlbtns
                end
            end
        elseif (istable(el)) then
            if (el.r) then
                defaultcolor = el
            elseif (el.font) then
                defaultfont = el.font
            elseif (el.linebreak) then
                forcebreak = true
            elseif (el.noparse ~= nil) then
                noparse = el.noparse
            elseif (el.bypass ~= nil) then
                bypassperm = el.bypass
            elseif (el.pre and i == 1) then
                ele = el.pre
                ele:SetParent(contents)
                pre = ele

                bx = bx + ele:GetWide() + (el.space or 0)
            elseif (el.url ~= nil) then
                url = el.url

                if (url == false) then
                    for _, v in ipairs (urlbtns) do
                        if (IsValid(v)) then
                            v.m_Buttons = table.Copy(urlbtns)
                        end
                    end

                    urlbtns = {}
                end
            elseif (el.origtext) then
                origtext = el.origtext
            elseif (el.lua ~= nil) then
                lua = el

                if (el.lua == false) then
                    for _, v in ipairs (luabtns) do
                        if (IsValid(v)) then
                            v.m_Buttons = table.Copy(luabtns)
                        end
                    end

                    luabtns = {}
                    lua = nil
                end
            elseif (el.underline ~= nil) then
                underline = el.underline
            end
        elseif (IsPlayer(el)) then
            local coltouse = team.GetColor(el:Team())
            if (ROLE_DETECTIVE and el.IsActiveDetective and el:IsActiveDetective()) then
                coltouse = Color(50, 200, 255)
            end

            ele = self:MakeChatLabel(el:Nick(), defaultfont, coltouse, contents)
        elseif (ispanel(el)) then
            ele = el
        end

        if (lua and ispanel(ele) and IsValid(ele)) then
            local func = lua.lua

            ele:SetMouseInputEnabled(true)
            ele:SetCursor("user")
            ele.m_Lua = lua

                local btn = vgui.Create("DButton", ele)
                btn:SetText("")
                btn:Dock(FILL)
                btn.Paint = function() end
                btn.DoClick = function(me)
                    func()
                end
                btn.DoRightClick = function(me)
                    line:ShowMenu()
                end
                ele.m_Button = btn

                if (lua.hover) then
                    btn.OnCursorEntered = function(me)
                        func()
                    end
                end
        end

        local function newl()
            if (lh == 0) then
                lh = draw.GetFontHeight(defaultfont)
            end

            x = bx
            h = h + lh
            y = y + lh
            lh = 0
            inline = {}
        end

        if (IsValid(ele)) then
            local wi, he = ele:GetWide(), ele:GetTall()
            if (i == 1 and bx > 0) then
                wi = math.max(wi, bx)
            end

            if (x + wi > maxwi) then
                newl()
            end

            if (he > lh) then
                lh = he

                -- center vertically all prior elements in the line to take in account the new line height
                for _, v in ipairs (inline) do
                    v:AlignTop(y + lh * 0.5 - v:GetTall() * 0.5)
                end
            end

            if (ele:GetName() ~= "DButton") then
                ele.OnMousePressed = function(me, mc)
                    line:OnMousePressed(mc)
                end
            end

            ele:SetPos(x, y + lh * 0.5 - he * 0.5)
            x = x + wi
            w = x
            table.insert(inline, ele)
        end

        if (nl or forcebreak) then
            newl()
            nl = false
            forcebreak = false
        end
    end

    if (lh > 0) then
        h = h + lh
    end

    line:SetSize(w, h)

    return line
end

function LOUNGE_CHAT:AddToChatbox(el, quickchat)
    if (!IsValid(_LOUNGE_CHAT)) then
        return end

    --
    el:SetAlpha(0)
    el:AlphaTo(255, self.Anims.FadeInTime)

    el.m_fLastVisible = RealTime()
    el.Think = function(me)
        -- Dynvis
        local sc = _LOUNGE_CHAT.m_iScrollMin
        local sc2 = _LOUNGE_CHAT.m_iScrollMax

        local a, b = me.y, me.y + me:GetTall()
        me.m_Contents:SetVisible((a >= sc and a <= sc2) or (b >= sc and b <= sc2))

        -- fadeout
        local rt = RealTime()
        if (!self.ChatboxOpen) then
            if (rt - me.m_fLastVisible >= chat_message_hidetime_cache and !me.m_bFading) then
                me.m_bFading = true
                me:AlphaTo(0, self.Anims.TextFadeOutTime)
            end
        else
            me.m_bFading = nil
            me.m_fLastVisible = rt
            me:Stop()
            me:SetAlpha(255)
        end
    end

    local his = _LOUNGE_CHAT.m_History
    local can = his:GetCanvas()

    if (self.MaxMessages > 0 and #can:GetChildren() > self.MaxMessages) then
        local i = 0
        while (#can:GetChildren() - i > self.MaxMessages) do
            local child = can:GetChild(i)
            if (IsValid(child)) then
                child:Remove()
                i = i + 1
            else
                break
            end
        end
    end

    his:AddItem(el)
    el:Dock(TOP)
    -- no
    can:SetTall(can:GetTall() + el:GetTall())
    his.VBar:SetUp(his:GetTall(), can:GetTall())

    if not (self.ChatboxOpen and chat_no_scroll_while_open:GetBool()) then
        -- his.VBar:SetScroll(can:GetTall() + el:GetTall())
        his:GetCanvas():InvalidateLayout(true)
        timer.Simple(0, function()
            if (!IsValid(his) or !IsValid(el)) then
                return end

            his:ScrollToBottom()
        end)
    end

    chat.PlaySound()

    return el
end

function LOUNGE_CHAT:OpenChatbox(bteam)
    if (self.ChatboxOpen) then
        return end

    hook.Call("StartChat", GAMEMODE, bteam)

    if (!IsValid(_LOUNGE_CHAT)) then
        self:CreateChatbox()
    end
    if (IsValid(_LOUNGE_CHAT_EMOTICONS)) then
        _LOUNGE_CHAT_EMOTICONS:SetVisible(false)
    end

    -- Fade in
    _LOUNGE_CHAT.m_fAlpha = 0
    _LOUNGE_CHAT:Stop()
    _LOUNGE_CHAT:NewAnimation(self.Anims.FadeInTime).Think = function(anim, me, frac)
        me.m_fAlpha = 255 * frac
    end

    --
    _LOUNGE_CHAT:MakePopup()

    _LOUNGE_CHAT.m_Entry.m_iCurPos = nil
    _LOUNGE_CHAT.m_Entry:RequestFocus()
    _LOUNGE_CHAT.m_bTeam = bteam

    self.ChatboxOpen = true

    net.Start("LOUNGE_CHAT.Typing")
        net.WriteBool(true)
    net.SendToServer()
end

function LOUNGE_CHAT:CloseChatbox()
    if (IsValid(_LOUNGE_CHAT_EMOTICONS)) then
        _LOUNGE_CHAT_EMOTICONS:Close()
    end

    self.ChatboxOpen = false

    net.Start("LOUNGE_CHAT.Typing")
        net.WriteBool(false)
    net.SendToServer()

    hook.Call("ChatTextChanged", GAMEMODE, "")
    hook.Call("FinishChat", GAMEMODE)

    -- Fade out
    local a = _LOUNGE_CHAT.m_fAlpha or 255

    _LOUNGE_CHAT:Stop()
    _LOUNGE_CHAT:NewAnimation(self.Anims.FadeOutTime * (a / 255)).Think = function(anim, me, frac)
        me.m_fAlpha = a * (1 - frac)
    end

    --
    _LOUNGE_CHAT:SetKeyboardInputEnabled(false)
    _LOUNGE_CHAT:SetMouseInputEnabled(false)

    _LOUNGE_CHAT.m_Entry:SetText("")
end

chat.OldGetChatBoxPos = chat.OldGetChatBoxPos or chat.GetChatBoxPos
chat.OldGetChatBoxSize = chat.OldGetChatBoxSize or chat.GetChatBoxSize
chat.OldAddText = chat.OldAddText or chat.AddText

function chat.GetChatBoxPos()
    if (IsValid(_LOUNGE_CHAT)) then
        return _LOUNGE_CHAT:GetPos()
    else
        return chat.OldGetChatBoxPos()
    end
end

function chat.GetChatBoxSize()
    if (IsValid(_LOUNGE_CHAT)) then
        return _LOUNGE_CHAT:GetSize()
    else
        return chat.OldGetChatBoxSize()
    end
end

function chat.AddText(...)
    local args = {...}

    local t = {}
    for _, v in pairs (args) do
        if (isstring(v)) then
            table.insert(t, v)
        end
    end
    local origtext = table.concat(t, "")
    table.insert(args, {origtext = origtext})

    chat.OldAddText(...)
    LOUNGE_CHAT:AddToChatbox(LOUNGE_CHAT:ParseLineWrap(args, true))
end

concommand.Add("lounge_chat_clear", function()
    _LOUNGE_CHAT.m_History:Clear()
end)

local con = {}
local tab = {}
local function Add(el, console, i)
    if (istable(el) and #el > 1) then
        table.Add(tab, el)
    else
        if (i) then
            table.insert(tab, i, el)
        else
            table.insert(tab, el)
        end
    end

    if (console) then
        if (istable(el) and !el.r) then
            table.Add(con, el)
        else
            if (i) then
                table.insert(con, i, el)
            else
                table.insert(con, el)
            end
        end
    end
end

local mply = FindMetaTable("Player")

function mply:CanSeeEnt( ent )



  local trace = {}

  trace.start = self:GetEyeTrace().StartPos

  trace.endpos = ent:EyePos()

  trace.filter = { self, ent }

  trace.mask = MASK_BULLET

  local tr = util.TraceLine( trace )



  if ( tr.Fraction == 1.0 ) then



    return true;



  end



  return false;



end

local Russian_Upper = {
    ["а"] = "А",
    ["б"] = "Б",

}

--helix
function ChatTextFormat(text)
    text = string.Trim(text)
    local last = utf8.sub(text, -1)

    if !string.StartWith(text, "!") and #string.Split(text, " ") > 2 then
	    if (last != "." and last != "?" and last != "!" and last != "-" and last != "\"") then
	        text = text .. "."
	    end
	end

    return string.upper(utf8.sub(text, 1, 1))..utf8.sub(text, 2)
end

function ChatTalkType(text, bteam)
    if bteam then
        return " шепчет: "
    end

    text = string.Trim(text)
    local last = utf8.sub(text, -1)

    if (last != "." and last != "?" and last != "!" and last != "-" and last != "\"") then
        text = text .. "."
        return " 说: "
    end

    if last == "." then
        return " 说: "
    end

    if last == "?" then
        return " 问: "
    end

    if last == "!" then
        return " 叫喊: "
    end

    return " 他说: "
end

-- this is terrible and should be rewritten
function LOUNGE_CHAT:OnPlayerChat(ply, text, bteam, bdead, preftext, prefcolor, color)
if !ply.Alive or !ply:Alive() then return end
if ply:IsMuted() then return end
    con = {}
    tab = {}

    if ply:GTeam() != TEAM_SPEC then
        ChatTextFormat(text)
    end

    local isquickchat = false

    if text:StartWith("quickchat_") then
    	local tr, isfound = BREACH.TranslateString("l:"..text)
    	if !isfound then return end
    	text = tr
    	text = text.."!"
    	isquickchat = true
    end

    Add({bypass = true})

    local textcol = color_white

    if isquickchat then textcol = Color(0,255,0) end

    local namecol = IsValid(ply) and team.GetColor(ply:Team()) or color_white

    if (IsValid(ply)) then
        local ccp = self.CustomColorsPlayers[ply:SteamID()] or self.CustomColorsPlayers[ply:SteamID64()]
        local ccu = self.CustomColorsGroups[ply:GetUserGroup()]
        namecol = ccp or ccu or namecol
    end

    -- (shitty) dayz tags
    if (engine.ActiveGamemode() == "dayz") or (DrawHPImage and DrawAmmoInfo) then
        local sign = text:sub(1, 1)
        if (self.DayZ_ChatTags[sign]) then
            local fs = string.find(text, " ")
            if (fs) then
                local cmd = self.sub(text, 2, fs - 1)
                local tag = self.DayZ_ChatTags[sign][cmd]
                if (tag) then
                    Add({tag.tagcolor, tag.tag}, true)
                    text = self.sub(text, fs + 1)
                end
            end
        end
    end

    if (IsValid(ply)) then


        -- TeamTags
        if (self.TeamTags) then
            local t = ply:Team()

            local tx = string.format(self.TeamTagsFormat, team.GetName(t))
            if (self.TeamTagsCase == 1) then
                tx = tx:upper()
            elseif (self.TeamTagsCase == -1) then
                tx = tx:lower()
            end

            Add({
                team.GetColor(t),
                tx
            })
        end

        if (!self.ProfanityBypass[ply:GetUserGroup()]) then
            for _, word in pairs (self.ProfanityFilter) do
                local tries = 0
                local s, e = string.find(text:lower(), word)
                while (s and tries <= 128) do
                    text = text:sub(1, s - 1) .. string.rep(self.CensorCharacter, e - s + 1) .. text:sub(e + 1)
                    tries = tries + 1
                    s, e = string.find(text, word)
                end
            end
        end
    end

    -- TTT detective color
    if (IsValid(ply) and ROLE_DETECTIVE and ply.IsActiveDetective and ply:IsActiveDetective()) then
        namecol = Color(50, 200, 255)
    end

    if (bdead) then
        Add(self.TagDead)
        table.Add(con, self.TagDeadConsole)
    end

    if (bteam) then
        if (bteam == true and IsValid(ply)) then
            Add({team.GetColor(ply:Team()), self.TagTeam})

            table.insert(con, team.GetColor(ply:Team()))
            table.Add(con, self.TagTeamConsole)
        elseif (istable(bteam) and bteam.color and bteam.text) then
            Add({bteam.color, bteam.text}, true)
        end
    end

    -- should be darkrp
    local darkrp = DarkRP and preftext and prefcolor and color
    if (darkrp) then
        if (preftext) then
            Add({prefcolor, preftext})
            textcol = messageColor or color
        end
    end

    if (IsValid(ply)) then
        if ply:GTeam() != TEAM_SPEC then
            if render_character_avatar:GetBool() then
                local av-- = self:DrawCharacterAvatar(ply)
                if ( ( LocalPlayer():CanSeeEnt(ply) and !ply:GetNoDraw() ) or ply == LocalPlayer() or ( ply:GTeam() == TEAM_SCP and LocalPlayer():GTeam() == TEAM_SCP ) ) or LocalPlayer():GTeam() == TEAM_SPEC then
                    av = self:DrawCharacterAvatar(ply)
                else
                    av = self:DrawUnknownCharacter(ply)
                end
                av.m_bMessageAvatar = true
        
                Add( {
        
                    pre = av,
                    space = 4,
        
                }, false, 1 )
            else
                m_bMessageAvatar = false
                Add( {
        
                    pre = nil,
                    space = 4,
        
                }, false, 1 )
            end

        else
            if (self.ShowPlayerAvatar and !GetConVar("lounge_chat_hide_avatars"):GetBool()) then
                local av = self:Avatar(ply)
                av.m_bMessageAvatar = true
    
                Add({
                    pre = av,
                    space = 4,
                }, false, 1)
            end
        end
    end

    local ts = chat_timestamps:GetBool()
    if (ts) then
        table.insert(con, 1, "[" .. self.Timestamp() .. "] ")
        table.insert(con, 1, self.Color("timestamp"))
    end

    if (self.MessageStyle == 0 and ts) then
        Add("<timestamp=" .. os.time() .. "> - ", nil, 2)
    end

    if (darkrp) then
        table.insert(con, prefcolor)
        table.insert(con, preftext)
        table.insert(con, textcol)
        table.insert(con, ": " .. text)
    else
        if (IsValid(ply)) then
        	if ply:GTeam() == TEAM_SPEC and ply:GetNLevel() >= 150 then
        		Add{color_white, ":yeet: ", true}
        	end
        	if ply:GetNWBool("prefix_active") then
        		if ply:GTeam() == TEAM_SPEC then
		        	local colt = string.Explode(",", ply:GetNWString("prefix_color", "255,255,255"))
		        	local color = Color(tonumber(colt[1]), tonumber(colt[2]), tonumber(colt[3]))
		        	local str = ply:GetNWString("prefix_title", "")
		        	if ply:GetNWBool("prefix_rainbow", false) then
		        		str = "<rainbow=1>["..str.."]</rainbow> "
		        	else
		        		str = "["..str.."] "
		        	end
		        	Add({color, str}, true)
		        end
        	elseif ply:GetUserGroup() != "premium" or ply:GetNWBool("display_premium_icon", true) then
	            if LOUNGE_CHAT.CustomTagsPlayers[ply:SteamID64()] and ( ply:GTeam() == TEAM_SPEC ) then
	                Add({Color(255, 255, 255), LOUNGE_CHAT.CustomTagsPlayers[ply:SteamID64()]}, true)
	            elseif LOUNGE_CHAT.CustomTagsPlayers[ply:SteamID()] and ( ply:GTeam() == TEAM_SPEC ) then
	                Add({Color(255, 255, 255), LOUNGE_CHAT.CustomTagsPlayers[ply:SteamID()]}, true)
	            elseif LOUNGE_CHAT.CustomTagsGroups[ply:GetUserGroup()] and ( ply:GTeam() == TEAM_SPEC ) then
	            	if langtouse and (langtouse == "russian" or langtouse == "ukraine") then
	            		Add({Color(255, 255, 255), LOUNGE_CHAT.CustomTagsGroups_RUSSIAN[ply:GetUserGroup()].." "}, true)
	            	else
		                Add({Color(255, 255, 255), LOUNGE_CHAT.CustomTagsGroups[ply:GetUserGroup()].." "}, true)
		            end
	            end
	        end
            local clr_gray_precache = Color( 198, 198, 198, 180 )
            if ply:GTeam() == TEAM_SCP then
                Add({GetClientColor(ply), ply:Nick()}, true)
                --Add({GetClientColor(ply), "("..GetLangRole(ply:GetRoleName())..")"})
            elseif ply:GTeam() != TEAM_SCP then
                if ply:GTeam() != TEAM_SPEC then
                    if LocalPlayer():CanSeeEnt(ply) then
                        local str = ply:GetNamesurvivor()
                        if LocalPlayer() != ply and LocalPlayer():IsAdmin() then str = str.." ("..ply:Nick()..")" end
                        Add({GetClientColor(ply), str}, true)
                    else
                        local str = "Неизвестный"
                        if LocalPlayer() != ply and LocalPlayer():IsAdmin() then str = str.." ("..ply:Nick()..")" end
                        Add({Color(255, 255, 255), str}, true)
                    end

                    Add( { clr_gray_precache, ChatTalkType(text, bteam) } )
                else
                    if LOUNGE_CHAT.CustomColorsPlayers[ply:SteamID64()] then
                        Add({LOUNGE_CHAT.CustomColorsPlayers[ply:SteamID64()], ply:Nick()}, true)
                    elseif LOUNGE_CHAT.CustomColorsPlayers[ply:SteamID()] then
                        Add({LOUNGE_CHAT.CustomColorsPlayers[ply:SteamID()], ply:Nick()}, true)
                    else
                        Add({GetClientColor(ply), ply:Nick()}, true)
                    end
                end
            else
                Add({namecol, ply:Nick()}, true)
            end
            if ply:GetNWBool("IntercomTalking") then
                Add({Color(255, 255, 255), "(INTERCOM)"}, true)
            end

        else
            Add(self.ConsoleName, true)
        end
    end

    if (self.MessageStyle == 1) then
        if (ts) then
            Add({textcol, " - <timestamp=" .. os.time() .. ">"}, nil, 2)
        end

        Add({linebreak = true})
    end

    Add({bypass = false})

    if ply:GTeam() != TEAM_SPEC then
        Add({textcol, (self.MessageStyle == 1 and "" or ": ") .."''"..text.."''"})
    else
        Add({textcol, (self.MessageStyle == 1 and "" or ": ").. text})
    end

    if (!darkrp) then
        table.Add(con, {textcol, ": " .. text})
    end

    -- console friendly message
    chat.OldAddText(unpack(con))

    -- actual message
    table.insert(tab, {origtext = text})
    self:AddToChatbox(self:ParseLineWrap(tab, true, nil, ply, false), isquickchat)
end

-- for developers. The text is not styled so you will have to do that yourself
-- The func is called when the player clicks on the message label
-- set hover to true to trigger the func on text hover
function LOUNGE_CHAT:AddLuaMessage(text, func, hover)
    local tab = {
        {origtext = text},
        {lua = func, hover = hover or false},
        text,
        {lua = false},
    }

    self:AddToChatbox(self:ParseLineWrap(tab, true, nil, ply))
end

LOUNGE_CHAT.LuaButtons = {}

function LOUNGE_CHAT:MakeLuaButton(text, func, hover)
    local i = #self.LuaButtons + 1
    self.LuaButtons[i] = func

    return "<luabtn=" .. i .. "," .. (hover and 1 or 0) .. ">" .. text .. "</luabtn>"
end

hook.Add("OnPlayerChat", "LOUNGE_CHAT.OnPlayerChat", function(ply, text, bteam, bdead, preftext, prefcolor, color)
	local cantchat = hook.Call("OnPlayerChatCheck", GAMEMODE, ply, text, bteam, bdead, preftext, prefcolor, color)
	if !cantchat then
	    LOUNGE_CHAT:OnPlayerChat(ply, text, bteam, bdead, preftext, prefcolor, color)
	end
    return true
end)

hook.Add("PlayerBindPress", "LOUNGE_CHAT.PlayerBindPress", function(ply, bind, press)
    if (bind:find("messagemode")) then
        LOUNGE_CHAT:OpenChatbox(bind:find("messagemode2"))
        return true
    end
end)

local chat_hide = {
    ["joinleave"] = true,
    ["namechange"] = true, --xyecocs
    ["servermsg"] = true
}

hook.Add("ChatText", "LOUNGE_CHAT.ChatText", function(index, name, text, typ)
    if (index ~= 0) then
        return
    end

    if chat_hide[typ] then
        return true
    end

    chat.AddText(text)
end)

hook.Add("HUDShouldDraw", "LOUNGE_CHAT.HUDShouldDraw", function(h)
    if (h == "CHudChat") then
        return false
    end
end)

LOUNGE_CHAT:CreateChatboxFonts()

hook.Add("InitPostEntity", "LOUNGE_CHAT.InitPostEntity", function()
    -- "Load twice because apparently once is not enough"
    LOUNGE_CHAT:CreateChatboxFonts()
end)

hook.Add("Think", "LOUNGE_CHAT.Think", function()
    if (IsValid(LocalPlayer())) then
        hook.Remove("Think", "LOUNGE_CHAT.Think")
        hook.Remove("OnPlayerChat", "ATAG_ChatTags")

        LOUNGE_CHAT:CreateChatbox()

        for _, v in pairs (messagequeue) do
            LOUNGE_CHAT:AddToChatbox(LOUNGE_CHAT:ParseLineWrap(v.cont, v.maxwi, v.parent, v.sender))
        end

        -- TTT override
        if (ROLE_TRAITOR) then
            net.Receive("TTT_RoleChat", LOUNGE_CHAT.TTT_RoleChat)
            net.Receive("TTT_LastWordsMsg", LOUNGE_CHAT.TTT_LastWordsMsg)
        end
    end
end)

-- shitty override for a shitty gamemode
net.Receive("LOUNGE_CHAT.TTTRadio", function()
    local sender = net.ReadEntity()
    local msg = net.ReadString()
    local param = net.ReadString()
    if not (IsValid(sender) and sender:IsPlayer()) then
        return end

    GAMEMODE:PlayerSentRadioCommand(sender, msg, param)

    -- if param is a language string, translate it
    -- else it's a nickname
    local lang_param = LANG.GetNameParam(param)
    if (lang_param) then
        if lang_param == "quick_corpse_id" then
            -- special case where nested translation is needed
            param = LANG.GetParamTranslation(lang_param, {player = net.ReadString()})
        else
            param = LANG.GetTranslation(lang_param)
        end
    end

    local text = LANG.GetParamTranslation(msg, {player = param})

    -- don't want to capitalize nicks, but everything else is fair game
    if (lang_param) then
        text = util.Capitalize(text)
    end

    if (sender:IsDetective()) then
        LOUNGE_CHAT:OnPlayerChat(
            sender,
            text,
            {
                color = Color(20, 100, 255),
                text = Format("(%s) ", string.upper(LANG.GetTranslation("detective")))
            },
            false
        )
    else
        LOUNGE_CHAT:OnPlayerChat(sender, text, false, false)
    end
end)

function LOUNGE_CHAT.TTT_RoleChat()
    local role = net.ReadUInt(2)
    local sender = net.ReadEntity()
    if not (IsValid(sender)) then
        return end

    local text = net.ReadString()

    if (role == ROLE_TRAITOR) then
        LOUNGE_CHAT:OnPlayerChat(
            sender,
            text,
            {
                color = Color(255, 30, 40),
                text = Format("(%s) ", string.upper(LANG.GetTranslation("traitor")))
            },
            false
        )
    elseif (role == ROLE_DETECTIVE) then
        LOUNGE_CHAT:OnPlayerChat(
            sender,
            text,
            {
                color = Color(20, 100, 255),
                text = Format("(%s) ", string.upper(LANG.GetTranslation("detective")))
            },
            false
        )
    end
end

function LOUNGE_CHAT.TTT_LastWordsMsg()
    local sender = net.ReadEntity()
    if not (IsValid(sender)) then
        return end

    local text = net.ReadString()

    LOUNGE_CHAT:OnPlayerChat(
        sender,
        text,
        {
            color = Color(150, 150, 150),
            text = Format("(%s) ", string.upper(LANG.GetTranslation("last_words"))),
        },
        false
    )
end